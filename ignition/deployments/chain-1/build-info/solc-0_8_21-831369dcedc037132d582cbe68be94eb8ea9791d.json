{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_21-831369dcedc037132d582cbe68be94eb8ea9791d",
  "solcVersion": "0.8.21",
  "solcLongVersion": "0.8.21+commit.d9974bed",
  "userSourceNameMap": {
    "contracts/payloads/IGP112/PayloadIGP112.sol": "project/contracts/payloads/IGP112/PayloadIGP112.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/payloads/common/constants.sol": {
        "content": "pragma solidity ^0.8.21;\npragma experimental ABIEncoderV2;\n\nimport {BigMathMinified} from \"../libraries/bigMathMinified.sol\";\nimport {LiquidityCalcs} from \"../libraries/liquidityCalcs.sol\";\nimport {LiquiditySlotsLink} from \"../libraries/liquiditySlotsLink.sol\";\n\nimport {IGovernorBravo} from \"./interfaces/IGovernorBravo.sol\";\nimport {ITimelock} from \"./interfaces/ITimelock.sol\";\n\nimport {IFluidLiquidityAdmin} from \"./interfaces/IFluidLiquidity.sol\";\nimport {IFluidReserveContract} from \"./interfaces/IFluidReserveContract.sol\";\n\nimport {IFluidVaultFactory} from \"./interfaces/IFluidVaultFactory.sol\";\nimport {IFluidDexFactory} from \"./interfaces/IFluidDexFactory.sol\";\nimport {IFluidSmartLendingFactory} from \"./interfaces/IFluidSmartLendingFactory.sol\";\nimport {IFluidLendingFactory} from \"./interfaces/IFluidLendingFactory.sol\";\n\nimport {IFluidDex} from \"./interfaces/IFluidDex.sol\";\nimport {IFluidDexResolver} from \"./interfaces/IFluidDex.sol\";\n\nimport {IFluidVault} from \"./interfaces/IFluidVault.sol\";\nimport {IFluidVaultT1} from \"./interfaces/IFluidVault.sol\";\n\nimport {IFTokenAdmin} from \"./interfaces/IFToken.sol\";\nimport {ILendingRewards} from \"./interfaces/IFToken.sol\";\n\nimport {IDSAV2} from \"./interfaces/IDSA.sol\";\n\nimport {ILite} from \"./interfaces/ILite.sol\";\n\nimport { IDSAConnectorsV2 } from \"./interfaces/IDSA.sol\";\n\ncontract PayloadIGPConstants {\n    address public immutable ADDRESS_THIS;\n\n    // Proposal Creators\n    address public constant PROPOSER =\n        0xA45f7bD6A5Ff45D31aaCE6bCD3d426D9328cea01;\n    address public constant PROPOSER_AVO_MULTISIG =\n        0x059A94A72951c0ae1cc1CE3BF0dB52421bbE8210;\n    address public constant PROPOSER_AVO_MULTISIG_2 =\n        0x9efdE135CA4832AbF0408c44c6f5f370eB0f35e8;\n    address public constant PROPOSER_AVO_MULTISIG_3 =\n        0x5C43AAC965ff230AC1cF63e924D0153291D78BaD;\n    address public constant PROPOSER_AVO_MULTISIG_4 =\n        0x3dAff61fe5cfB1f1B4eA7FBa8173A58532Ef1841;\n    address public constant PROPOSER_AVO_MULTISIG_5 =\n        0xE7EB63a8B6392481A9FDEbb108Cfd580DC8664d3;\n\n    // Governance Addresses\n    IGovernorBravo public constant GOVERNOR =\n        IGovernorBravo(0x0204Cd037B2ec03605CFdFe482D8e257C765fA1B);\n    ITimelock public constant TIMELOCK =\n        ITimelock(0x2386DC45AdDed673317eF068992F19421B481F4c);\n    IDSAV2 public constant TREASURY =\n        IDSAV2(0x28849D2b63fA8D361e5fc15cB8aBB13019884d09);\n    IDSAConnectorsV2 public constant DSA_CONNECTORS_V2 =\n        IDSAConnectorsV2(0x97b0B3A8bDeFE8cB9563a3c610019Ad10DB8aD11);\n\n    // Team Multisig\n    address public constant TEAM_MULTISIG =\n        0x4F6F977aCDD1177DCD81aB83074855EcB9C2D49e;\n    address public constant TEAM_MULTISIG_2 =\n        0x1e2e1aeD876f67Fe4Fd54090FD7B8F57Ce234219;\n\n    // Fluid Addresses\n    IFluidLiquidityAdmin public constant LIQUIDITY =\n        IFluidLiquidityAdmin(0x52Aa899454998Be5b000Ad077a46Bbe360F4e497);\n    IFluidReserveContract public constant FLUID_RESERVE =\n        IFluidReserveContract(0x264786EF916af64a1DB19F513F24a3681734ce92);\n    address public constant RESERVE_CONTRACT_PROXY =\n        0x264786EF916af64a1DB19F513F24a3681734ce92;\n\n    // Fluid Factory Addresses\n    IFluidVaultFactory public constant VAULT_FACTORY =\n        IFluidVaultFactory(0x324c5Dc1fC42c7a4D43d92df1eBA58a54d13Bf2d);\n    IFluidDexFactory public constant DEX_FACTORY =\n        IFluidDexFactory(0x91716C4EDA1Fb55e84Bf8b4c7085f84285c19085);\n    IFluidSmartLendingFactory public constant SMART_LENDING_FACTORY =\n        IFluidSmartLendingFactory(0xe57227C7d5900165344b190fc7aa580bceb53B9B);\n    IFluidLendingFactory public constant LENDING_FACTORY =\n        IFluidLendingFactory(0x54B91A0D94cb471F37f949c60F7Fa7935b551D03);\n\n    ILite public constant IETHV2 =\n        ILite(0xA0D3707c569ff8C87FA923d3823eC5D81c98Be78);\n\n    // Tokens\n    address internal constant ETH_ADDRESS =\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address internal constant WETH_ADDRESS =\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address internal constant wstETH_ADDRESS =\n        0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address internal constant stETH_ADDRESS =\n        0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\n    address internal constant weETH_ADDRESS =\n        0xCd5fE23C85820F7B72D0926FC9b05b43E359b7ee;\n    address internal constant rsETH_ADDRESS =\n        0xA1290d69c65A6Fe4DF752f95823fae25cB99e5A7;\n    address internal constant weETHs_ADDRESS =\n        0x917ceE801a67f933F2e6b33fC0cD1ED2d5909D88;\n    address internal constant mETH_ADDRESS =\n        0xd5F7838F5C461fefF7FE49ea5ebaF7728bB0ADfa;\n    address internal constant ezETH_ADDRESS =\n        0xbf5495Efe5DB9ce00f80364C8B423567e58d2110;\n\n    address internal constant USDC_ADDRESS =\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n    address internal constant USDT_ADDRESS =\n        0xdAC17F958D2ee523a2206206994597C13D831ec7;\n    address internal constant sUSDe_ADDRESS =\n        0x9D39A5DE30e57443BfF2A8307A4256c8797A3497;\n    address internal constant syrupUSDC_ADDRESS =\n        0x80ac24aA929eaF5013f6436cdA2a7ba190f5Cc0b;\n    address internal constant syrupUSDT_ADDRESS =\n        0x356B8d89c1e1239Cbbb9dE4815c39A1474d5BA7D;\n    address internal constant sUSDs_ADDRESS =\n        0xa3931d71877C0E7a3148CB7Eb4463524FEc27fbD;\n    address internal constant USDe_ADDRESS =\n        0x4c9EDD5852cd905f086C759E8383e09bff1E68B3;\n    address internal constant GHO_ADDRESS =\n        0x40D16FC0246aD3160Ccc09B8D0D3A2cD28aE6C2f;\n    address internal constant iUSD_ADDRESS =\n        0x48f9e38f3070AD8945DFEae3FA70987722E3D89c;\n    address internal constant deUSD_ADDRESS =\n        0x15700B564Ca08D9439C58cA5053166E8317aa138;\n    address internal constant USR_ADDRESS =\n        0x66a1E37c9b0eAddca17d3662D6c05F4DECf3e110;\n    address internal constant USD0_ADDRESS =\n        0x73A15FeD60Bf67631dC6cd7Bc5B6e8da8190aCF5;\n    address internal constant fxUSD_ADDRESS =\n        0x085780639CC2cACd35E474e71f4d000e2405d8f6;\n    address internal constant BOLD_ADDRESS =\n        0xb01dd87B29d187F3E3a4Bf6cdAebfb97F3D9aB98;\n    address internal constant USDTb_ADDRESS =\n        0xC139190F447e929f090Edeb554D95AbB8b18aC1C;\n    address internal constant csUSDL_ADDRESS =\n        0xbEeFc011e94f43b8B7b455eBaB290C7Ab4E216f1;\n    address internal constant JRUSDE_ADDRESS =\n        0xC58D044404d8B14e953C115E67823784dEA53d8F;\n    address internal constant SRUSDE_ADDRESS =\n        0x3d7d6fdf07EE548B939A80edbc9B2256d0cdc003;\n\n    address internal constant WBTC_ADDRESS =\n        0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\n    address internal constant cbBTC_ADDRESS =\n        0xcbB7C0000aB88B473b1f5aFd9ef808440eed33Bf;\n    address internal constant tBTC_ADDRESS =\n        0x18084fbA666a33d37592fA2633fD49a74DD93a88;\n    address internal constant eBTC_ADDRESS =\n        0x657e8C867D8B37dCC18fA4Caead9C45EB088C642;\n    address internal constant lBTC_ADDRESS =\n        0x8236a87084f8B84306f72007F36F2618A5634494;\n\n    address internal constant INST_ADDRESS =\n        0x6f40d4A6237C257fff2dB00FA0510DeEECd303eb;\n    address internal constant FLUID_ADDRESS =\n        0x6f40d4A6237C257fff2dB00FA0510DeEECd303eb;\n\n    address internal constant RLP_ADDRESS =\n        0x4956b52aE2fF65D74CA2d61207523288e4528f96;\n    address internal constant wstUSR_ADDRESS =\n        0x1202F5C7b4B9E47a1A484E8B270be34dbbC75055;\n\n    address internal constant XAUT_ADDRESS =\n        0x68749665FF8D2d112Fa859AA293F07A622782F38;\n    address internal constant PAXG_ADDRESS =\n        0x45804880De22913dAFE09f4980848ECE6EcbAf78;\n\n    // fTokens\n    address internal constant F_USDT_ADDRESS =\n        0x5C20B550819128074FD538Edf79791733ccEdd18;\n    address internal constant F_USDC_ADDRESS =\n        0x9Fb7b4477576Fe5B32be4C1843aFB1e55F251B33;\n    address internal constant F_WETH_ADDRESS =\n        0x90551c1795392094FE6D29B758EcCD233cFAa260;\n    address internal constant F_WSTETH_ADDRESS =\n        0x2411802D8BEA09be0aF8fD8D08314a63e706b29C;\n    address internal constant F_GHO_ADDRESS =\n        0x6A29A46E21C730DcA1d8b23d637c101cec605C5B;\n    address internal constant F_SUSDs_ADDRESS =\n        0x2BBE31d63E6813E3AC858C04dae43FB2a72B0D11;\n    address internal constant F_USDTb_ADDRESS =\n        0x15e8c742614b5D8Db4083A41Df1A14F5D2bFB400;\n\n    // Constants\n    uint256 internal constant X8 = 0xff;\n    uint256 internal constant X10 = 0x3ff;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X17 = 0x1ffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xff;\n\n    constructor() {\n        ADDRESS_THIS = address(this);\n    }\n}\n"
      },
      "project/contracts/payloads/common/helpers.sol": {
        "content": "pragma solidity ^0.8.21;\npragma experimental ABIEncoderV2;\n\nimport {BigMathMinified} from \"../libraries/bigMathMinified.sol\";\nimport {LiquidityCalcs} from \"../libraries/liquidityCalcs.sol\";\nimport {LiquiditySlotsLink} from \"../libraries/liquiditySlotsLink.sol\";\n\nimport {DexSlotsLink} from \"../libraries/dexSlotsLink.sol\";\n\nimport {IGovernorBravo} from \"./interfaces/IGovernorBravo.sol\";\nimport {ITimelock} from \"./interfaces/ITimelock.sol\";\n\nimport {IFluidLiquidityAdmin, AdminModuleStructs as FluidLiquidityAdminStructs} from \"./interfaces/IFluidLiquidity.sol\";\nimport {IFluidReserveContract} from \"./interfaces/IFluidReserveContract.sol\";\n\nimport {IFluidVaultFactory} from \"./interfaces/IFluidVaultFactory.sol\";\nimport {IFluidDexFactory} from \"./interfaces/IFluidDexFactory.sol\";\nimport {IFluidLendingFactory} from \"./interfaces/IFluidLendingFactory.sol\";\n\nimport {IFluidDex, IFluidAdminDex} from \"./interfaces/IFluidDex.sol\";\nimport {IFluidDexResolver} from \"./interfaces/IFluidDex.sol\";\n\nimport {IFluidVault} from \"./interfaces/IFluidVault.sol\";\nimport {IFluidVaultT1} from \"./interfaces/IFluidVault.sol\";\n\nimport {IFTokenAdmin} from \"./interfaces/IFToken.sol\";\nimport {ILendingRewards} from \"./interfaces/IFToken.sol\";\n\nimport {ISmartLendingAdmin} from \"./interfaces/ISmartLending.sol\";\n\nimport {IDSAV2} from \"./interfaces/IDSA.sol\";\n\nimport {PayloadIGPConstants} from \"./constants.sol\";\n\ncontract PayloadIGPHelpers is PayloadIGPConstants {\n    /**\n     * |\n     * |     Proposal Payload Helpers      |\n     * |__________________________________\n     */\n    function getVaultAddress(uint256 vaultId_) public view returns (address) {\n        return VAULT_FACTORY.getVaultAddress(vaultId_);\n    }\n\n    function getDexAddress(uint256 dexId_) public view returns (address) {\n        return DEX_FACTORY.getDexAddress(dexId_);\n    }\n\n    function getFTokenAddress(address token) public view returns (address) {\n        if (token == WETH_ADDRESS) {\n            return LENDING_FACTORY.computeToken(token, \"NativeUnderlying\");\n        }\n        return LENDING_FACTORY.computeToken(token, \"fToken\");\n    }\n\n    function getCurrentBaseWithdrawalLimit(\n        address token_,\n        address user_\n    ) internal view returns (uint256) {\n        bytes32 _LIQUDITY_PROTOCOL_SUPPLY_SLOT = LiquiditySlotsLink\n            .calculateDoubleMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT,\n                user_,\n                token_\n            );\n\n        uint256 userSupplyData_ = LIQUIDITY.readFromStorage(\n            _LIQUDITY_PROTOCOL_SUPPLY_SLOT\n        );\n\n        return\n            BigMathMinified.fromBigNumber(\n                (userSupplyData_ >>\n                    LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) &\n                    X18,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n    }\n\n    function setProtocolSupplyExpansion(\n        address protocol,\n        address token,\n        uint256 expandPercent,\n        uint256 expandDuration\n    ) internal {\n        FluidLiquidityAdminStructs.UserSupplyConfig[]\n            memory configs_ = new FluidLiquidityAdminStructs.UserSupplyConfig[](\n                1\n            );\n        configs_[0] = FluidLiquidityAdminStructs.UserSupplyConfig({\n            user: protocol,\n            token: token,\n            mode: 1,\n            expandPercent: expandPercent,\n            expandDuration: expandDuration,\n            baseWithdrawalLimit: getCurrentBaseWithdrawalLimit(token, protocol) // Keep existing limit\n        });\n        LIQUIDITY.updateUserSupplyConfigs(configs_);\n    }\n\n    /// @dev gets a smart lending address based on the underlying dexId\n    function getSmartLendingAddress(\n        uint256 dexId_\n    ) public view returns (address) {\n        return SMART_LENDING_FACTORY.getSmartLendingAddress(dexId_);\n    }\n\n    struct SupplyProtocolConfig {\n        address protocol;\n        address supplyToken;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseWithdrawalLimitInUSD;\n    }\n\n    struct BorrowProtocolConfig {\n        address protocol;\n        address borrowToken;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimitInUSD;\n        uint256 maxBorrowLimitInUSD;\n    }\n\n    function setSupplyProtocolLimits(\n        SupplyProtocolConfig memory protocolConfig_\n    ) internal {\n        {\n            // Supply Limits\n            FluidLiquidityAdminStructs.UserSupplyConfig[]\n                memory configs_ = new FluidLiquidityAdminStructs.UserSupplyConfig[](\n                    1\n                );\n\n            configs_[0] = FluidLiquidityAdminStructs.UserSupplyConfig({\n                user: address(protocolConfig_.protocol),\n                token: protocolConfig_.supplyToken,\n                mode: 1,\n                expandPercent: protocolConfig_.expandPercent,\n                expandDuration: protocolConfig_.expandDuration,\n                baseWithdrawalLimit: getRawAmount(\n                    protocolConfig_.supplyToken,\n                    0,\n                    protocolConfig_.baseWithdrawalLimitInUSD,\n                    true\n                )\n            });\n\n            LIQUIDITY.updateUserSupplyConfigs(configs_);\n        }\n    }\n\n    function setBorrowProtocolLimits(\n        BorrowProtocolConfig memory protocolConfig_\n    ) internal {\n        {\n            // Borrow Limits\n            FluidLiquidityAdminStructs.UserBorrowConfig[]\n                memory configs_ = new FluidLiquidityAdminStructs.UserBorrowConfig[](\n                    1\n                );\n\n            configs_[0] = FluidLiquidityAdminStructs.UserBorrowConfig({\n                user: address(protocolConfig_.protocol),\n                token: protocolConfig_.borrowToken,\n                mode: 1,\n                expandPercent: protocolConfig_.expandPercent,\n                expandDuration: protocolConfig_.expandDuration,\n                baseDebtCeiling: getRawAmount(\n                    protocolConfig_.borrowToken,\n                    0,\n                    protocolConfig_.baseBorrowLimitInUSD,\n                    false\n                ),\n                maxDebtCeiling: getRawAmount(\n                    protocolConfig_.borrowToken,\n                    0,\n                    protocolConfig_.maxBorrowLimitInUSD,\n                    false\n                )\n            });\n\n            LIQUIDITY.updateUserBorrowConfigs(configs_);\n        }\n    }\n\n    function setSupplyProtocolLimitsPaused(\n        address protocol_,\n        address token_\n    ) internal {\n        {\n            // Supply Limits\n            FluidLiquidityAdminStructs.UserSupplyConfig[]\n                memory configs_ = new FluidLiquidityAdminStructs.UserSupplyConfig[](\n                    1\n                );\n\n            configs_[0] = FluidLiquidityAdminStructs.UserSupplyConfig({\n                user: protocol_,\n                token: token_,\n                mode: 1,\n                expandPercent: 1, // 0.01%\n                expandDuration: 16777215, // max time\n                baseWithdrawalLimit: 10\n            });\n\n            LIQUIDITY.updateUserSupplyConfigs(configs_);\n        }\n    }\n\n    function setBorrowProtocolLimitsPaused(\n        address protocol_,\n        address token_\n    ) internal {\n        {\n            // Borrow Limits\n            FluidLiquidityAdminStructs.UserBorrowConfig[]\n                memory configs_ = new FluidLiquidityAdminStructs.UserBorrowConfig[](\n                    1\n                );\n\n            configs_[0] = FluidLiquidityAdminStructs.UserBorrowConfig({\n                user: protocol_,\n                token: token_,\n                mode: 1,\n                expandPercent: 1, // 0.01%\n                expandDuration: 16777215, // max time\n                baseDebtCeiling: 10,\n                maxDebtCeiling: 20\n            });\n\n            LIQUIDITY.updateUserBorrowConfigs(configs_);\n        }\n    }\n\n    function setSupplyProtocolLimitsPausedDex(\n        address dex_,\n        address user_\n    ) internal {\n        {\n            // Supply Limits for DEX - using DEX-specific interface\n            IFluidAdminDex.UserSupplyConfig[]\n                memory configs_ = new IFluidAdminDex.UserSupplyConfig[](1);\n\n            configs_[0] = IFluidAdminDex.UserSupplyConfig({\n                user: user_,\n                expandPercent: 1, // 0.01%\n                expandDuration: 16777215, // max time\n                baseWithdrawalLimit: 10 // minimal limit for pausing\n            });\n\n            IFluidDex(dex_).updateUserSupplyConfigs(configs_);\n        }\n    }\n\n    function setBorrowProtocolLimitsPausedDex(\n        address dex_,\n        address user_\n    ) internal {\n        {\n            // Borrow Limits for DEX - using DEX-specific interface\n            IFluidAdminDex.UserBorrowConfig[]\n                memory configs_ = new IFluidAdminDex.UserBorrowConfig[](1);\n\n            configs_[0] = IFluidAdminDex.UserBorrowConfig({\n                user: user_,\n                expandPercent: 1, // 0.01%\n                expandDuration: 16777215, // max time\n                baseDebtCeiling: 10, // minimal limit for pausing\n                maxDebtCeiling: 20 // minimal limit for pausing\n            });\n\n            IFluidDex(dex_).updateUserBorrowConfigs(configs_);\n        }\n    }\n\n    struct DexBorrowProtocolConfigInShares {\n        address dex;\n        address protocol;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseBorrowLimit;\n        uint256 maxBorrowLimit;\n    }\n\n    function setDexBorrowProtocolLimitsInShares(\n        DexBorrowProtocolConfigInShares memory protocolConfig_\n    ) internal {\n        IFluidAdminDex.UserBorrowConfig[]\n            memory config_ = new IFluidAdminDex.UserBorrowConfig[](1);\n        config_[0] = IFluidAdminDex.UserBorrowConfig({\n            user: protocolConfig_.protocol,\n            expandPercent: protocolConfig_.expandPercent,\n            expandDuration: protocolConfig_.expandDuration,\n            baseDebtCeiling: protocolConfig_.baseBorrowLimit,\n            maxDebtCeiling: protocolConfig_.maxBorrowLimit\n        });\n\n        IFluidDex(protocolConfig_.dex).updateUserBorrowConfigs(config_);\n    }\n\n    function getRawAmount(\n        address token,\n        uint256 amount,\n        uint256 amountInUSD,\n        bool isSupply\n    ) public view virtual returns (uint256) {\n        return 0;\n    }\n\n    struct DexConfig {\n        address dex;\n        address tokenA;\n        address tokenB;\n        bool smartCollateral;\n        bool smartDebt;\n        uint256 baseWithdrawalLimitInUSD;\n        uint256 baseBorrowLimitInUSD;\n        uint256 maxBorrowLimitInUSD;\n    }\n\n    enum VAULT_TYPE {\n        TYPE_1,\n        TYPE_2,\n        TYPE_3,\n        TYPE_4\n    }\n\n    struct VaultConfig {\n        address vault;\n        VAULT_TYPE vaultType;\n        address supplyToken;\n        address borrowToken;\n        uint256 baseWithdrawalLimitInUSD;\n        uint256 baseBorrowLimitInUSD;\n        uint256 maxBorrowLimitInUSD;\n    }\n\n    function setDexLimits(DexConfig memory dex_) internal {\n        // Smart Collateral\n        if (dex_.smartCollateral) {\n            SupplyProtocolConfig\n                memory protocolConfigTokenA_ = SupplyProtocolConfig({\n                    protocol: dex_.dex,\n                    supplyToken: dex_.tokenA,\n                    expandPercent: 50 * 1e2, // 50%\n                    expandDuration: 1 hours, // 1 hour\n                    baseWithdrawalLimitInUSD: dex_.baseWithdrawalLimitInUSD\n                });\n\n            setSupplyProtocolLimits(protocolConfigTokenA_);\n\n            SupplyProtocolConfig\n                memory protocolConfigTokenB_ = SupplyProtocolConfig({\n                    protocol: dex_.dex,\n                    supplyToken: dex_.tokenB,\n                    expandPercent: 50 * 1e2, // 50%\n                    expandDuration: 1 hours, // 1 hour\n                    baseWithdrawalLimitInUSD: dex_.baseWithdrawalLimitInUSD\n                });\n\n            setSupplyProtocolLimits(protocolConfigTokenB_);\n        }\n\n        // Smart Debt\n        if (dex_.smartDebt) {\n            BorrowProtocolConfig\n                memory protocolConfigTokenA_ = BorrowProtocolConfig({\n                    protocol: dex_.dex,\n                    borrowToken: dex_.tokenA,\n                    expandPercent: 50 * 1e2, // 50%\n                    expandDuration: 1 hours, // 1 hour\n                    baseBorrowLimitInUSD: dex_.baseBorrowLimitInUSD,\n                    maxBorrowLimitInUSD: dex_.maxBorrowLimitInUSD\n                });\n\n            setBorrowProtocolLimits(protocolConfigTokenA_);\n\n            BorrowProtocolConfig\n                memory protocolConfigTokenB_ = BorrowProtocolConfig({\n                    protocol: dex_.dex,\n                    borrowToken: dex_.tokenB,\n                    expandPercent: 50 * 1e2, // 50%\n                    expandDuration: 1 hours, // 1 hour\n                    baseBorrowLimitInUSD: dex_.baseBorrowLimitInUSD,\n                    maxBorrowLimitInUSD: dex_.maxBorrowLimitInUSD\n                });\n\n            setBorrowProtocolLimits(protocolConfigTokenB_);\n        }\n    }\n\n    function setVaultLimits(VaultConfig memory vault_) internal {\n        if (vault_.vaultType == VAULT_TYPE.TYPE_1) {\n            SupplyProtocolConfig memory protocolConfig_ = SupplyProtocolConfig({\n                protocol: vault_.vault,\n                supplyToken: vault_.supplyToken,\n                expandPercent: 50 * 1e2, // 50%\n                expandDuration: 6 hours, // 6 hours\n                baseWithdrawalLimitInUSD: vault_.baseWithdrawalLimitInUSD\n            });\n\n            setSupplyProtocolLimits(protocolConfig_);\n        }\n\n        if (vault_.vaultType == VAULT_TYPE.TYPE_1) {\n            BorrowProtocolConfig memory protocolConfig_ = BorrowProtocolConfig({\n                protocol: vault_.vault,\n                borrowToken: vault_.borrowToken,\n                expandPercent: 50 * 1e2, // 50%\n                expandDuration: 6 hours, // 6 hours\n                baseBorrowLimitInUSD: vault_.baseBorrowLimitInUSD,\n                maxBorrowLimitInUSD: vault_.maxBorrowLimitInUSD\n            });\n\n            setBorrowProtocolLimits(protocolConfig_);\n        }\n\n        if (vault_.vaultType == VAULT_TYPE.TYPE_2) {\n            BorrowProtocolConfig memory protocolConfig_ = BorrowProtocolConfig({\n                protocol: vault_.vault,\n                borrowToken: vault_.borrowToken,\n                expandPercent: 30 * 1e2, // 30%\n                expandDuration: 6 hours, // 6 hours\n                baseBorrowLimitInUSD: vault_.baseBorrowLimitInUSD,\n                maxBorrowLimitInUSD: vault_.maxBorrowLimitInUSD\n            });\n\n            setBorrowProtocolLimits(protocolConfig_);\n        }\n\n        if (vault_.vaultType == VAULT_TYPE.TYPE_3) {\n            SupplyProtocolConfig memory protocolConfig_ = SupplyProtocolConfig({\n                protocol: vault_.vault,\n                supplyToken: vault_.supplyToken,\n                expandPercent: 35 * 1e2, // 35%\n                expandDuration: 6 hours, // 6 hours\n                baseWithdrawalLimitInUSD: vault_.baseWithdrawalLimitInUSD\n            });\n\n            setSupplyProtocolLimits(protocolConfig_);\n        }\n    }\n\n    function updateDexBaseLimits(\n        uint256 dexId,\n        uint256 maxSupplySharesInUSD,\n        uint256 maxBorrowSharesInUSD\n    ) internal {\n        address dexAddress = getDexAddress(dexId);\n        if (dexAddress == address(0)) return;\n\n        (address AddressTokenA, address AddressTokenB) = getDexTokens(\n            dexAddress\n        );\n\n        uint256 baseWithdrawalInUSD = (maxSupplySharesInUSD * 45) / 100; // 45% of supply cap\n        uint256 baseBorrowInUSD = (maxBorrowSharesInUSD * 60) / 100; // 60% of max borrow cap\n        uint256 maxBorrowInUSD = (maxBorrowSharesInUSD * 125) / 100; // 25% increase\n\n        DexConfig memory dex_ = DexConfig({\n            dex: dexAddress,\n            tokenA: AddressTokenA,\n            tokenB: AddressTokenB,\n            smartCollateral: maxSupplySharesInUSD > 0,\n            smartDebt: maxBorrowSharesInUSD > 0,\n            baseWithdrawalLimitInUSD: baseWithdrawalInUSD,\n            baseBorrowLimitInUSD: baseBorrowInUSD,\n            maxBorrowLimitInUSD: maxBorrowInUSD\n        });\n        setDexLimits(dex_);\n    }\n\n    function getDexTokens(\n        address dexAddress_\n    ) internal view returns (address, address) {\n        IFluidDex.ConstantViews memory constantViews_ = IFluidDex(dexAddress_)\n            .constantsView();\n\n        return (constantViews_.token0, constantViews_.token1);\n    }\n\n    function updateDexRevenueCut(uint256 dexId, uint256 revenueCut) internal {\n        address dexAddress = getDexAddress(dexId);\n        uint256 dexVariables2_ = IFluidDex(dexAddress).readFromStorage(\n            bytes32(DexSlotsLink.DEX_VARIABLES2_SLOT)\n        );\n        uint256 fee_ = (dexVariables2_ >> 2) & X17;\n\n        IFluidDex(dexAddress).updateFeeAndRevenueCut(\n            fee_, // fee stays the same\n            revenueCut\n        );\n    }\n}\n"
      },
      "project/contracts/payloads/common/interfaces/ICodeReader.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\ninterface ICodeReader {\n    function readCode(address target) external view returns (bytes memory);\n} "
      },
      "project/contracts/payloads/common/interfaces/IDSA.sol": {
        "content": "pragma solidity ^0.8.21;\n\ninterface IDSAV2 {\n    function cast(\n        string[] memory _targetNames,\n        bytes[] memory _datas,\n        address _origin\n    )\n    external\n    payable \n    returns (bytes32);\n\n    function isAuth(address user) external view returns (bool);\n}\n\ninterface IDSAConnectorsV2 {\n    function toggleChief(address _chiefAddress) external;\n}\n"
      },
      "project/contracts/payloads/common/interfaces/IERC20.sol": {
        "content": "pragma solidity ^0.8.21;\n\ninterface IERC20 {\n    function allowance(\n        address spender,\n        address caller\n    ) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}"
      },
      "project/contracts/payloads/common/interfaces/IFluidDex.sol": {
        "content": "pragma solidity ^0.8.21;\n\ninterface IFluidAdminDex {\n    /// @param upperThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param lowerThresholdPercent_ in 4 decimals, 10000 = 1%\n    /// @param thresholdShiftTime_ in secs, in how much time the threshold percent should take to shift the ranges\n    /// @param shiftTime_ in secs, in how much time the upper config changes should be fully done.\n    function updateThresholdPercent(\n        uint upperThresholdPercent_,\n        uint lowerThresholdPercent_,\n        uint thresholdShiftTime_,\n        uint shiftTime_\n    ) external;\n\n    function updateCenterPriceLimits(\n        uint maxCenterPrice_,\n        uint minCenterPrice_\n    ) external;\n\n    function updateCenterPriceAddress(\n        uint centerPriceAddress_,\n        uint percent_,\n        uint time_\n    ) external;\n\n    function readFromStorage(\n        bytes32 slot_\n    ) external view returns (uint256 result_);\n\n    function updateMaxSupplyShares(uint maxSupplyShares_) external;\n\n    function updateMaxBorrowShares(uint maxBorrowShares_) external;\n\n    /// @notice struct to set user supply & withdrawal config\n    struct UserSupplyConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param expandPercent withdrawal limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which withdrawal limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration withdrawal limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseWithdrawalLimit base limit, below this, user can withdraw the entire amount.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseWithdrawalLimit;\n    }\n\n    /// @notice struct to set user borrow & payback config\n    struct UserBorrowConfig {\n        ///\n        /// @param user address\n        address user;\n        ///\n        /// @param expandPercent debt limit expand percent. in 1e2: 100% = 10_000; 1% = 100\n        /// Also used to calculate rate at which debt limit should decrease (instant).\n        uint256 expandPercent;\n        ///\n        /// @param expandDuration debt limit expand duration in seconds.\n        /// used to calculate rate together with expandPercent\n        uint256 expandDuration;\n        ///\n        /// @param baseDebtCeiling base borrow limit. until here, borrow limit remains as baseDebtCeiling\n        /// (user can borrow until this point at once without stepped expansion). Above this, automated limit comes in place.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 baseDebtCeiling;\n        ///\n        /// @param maxDebtCeiling max borrow ceiling, maximum amount the user can borrow.\n        /// amount in raw (to be multiplied with exchange price) or normal depends on configured mode in user config for the token:\n        /// with interest -> raw, without interest -> normal\n        uint256 maxDebtCeiling;\n    }\n\n    function updateUserBorrowConfigs(\n        UserBorrowConfig[] memory userBorrowConfigs_\n    ) external;\n\n    function updateUserSupplyConfigs(\n        UserSupplyConfig[] memory userSupplyConfigs_\n    ) external;\n\n    struct InitializeVariables {\n        bool smartCol;\n        uint token0ColAmt;\n        bool smartDebt;\n        uint token0DebtAmt;\n        uint centerPrice;\n        uint fee;\n        uint revenueCut;\n        uint upperPercent;\n        uint lowerPercent;\n        uint upperShiftThreshold;\n        uint lowerShiftThreshold;\n        uint thresholdShiftTime;\n        uint centerPriceAddress;\n        uint hookAddress;\n        uint maxCenterPrice;\n        uint minCenterPrice;\n    }\n\n    function initialize(InitializeVariables memory initializeVariables_) external payable;\n\n    function updateRangePercents(\n        uint upperPercent_,\n        uint lowerPercent_,\n        uint shiftTime_\n    ) external; \n\n    /// @param fee_ in 4 decimals, 10000 = 1%\n    /// @param revenueCut_ in 4 decimals, 100000 = 10%, 10% cut on fee_, so if fee is 1% and cut is 10% then cut in swap amount will be 10% of 1% = 0.1%\n    function updateFeeAndRevenueCut(uint fee_, uint revenueCut_) external;\n\n    /// @notice pause user operations at DEX level\n    /// @param user_ address of user to pause operations for\n    /// @param pauseSupply_ whether to pause supply operations\n    /// @param pauseBorrow_ whether to pause borrow operations\n    function pauseUser(address user_, bool pauseSupply_, bool pauseBorrow_) external;\n\n    function pauseSwapAndArbitrage() external;\n}\n\ninterface IFluidUserDex {\n\n\n    struct Implementations {\n        address shift;\n        address admin;\n        address colOperations;\n        address debtOperations;\n        address perfectOperationsAndOracle;\n    }\n\n    struct ConstantViews {\n        uint256 dexId;\n        address liquidity;\n        address factory;\n        Implementations implementations;\n        address deployerContract;\n        address token0;\n        address token1;\n        bytes32 supplyToken0Slot;\n        bytes32 borrowToken0Slot;\n        bytes32 supplyToken1Slot;\n        bytes32 borrowToken1Slot;\n        bytes32 exchangePriceToken0Slot;\n        bytes32 exchangePriceToken1Slot;\n        uint256 oracleMapping;\n    }\n\n\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n}\n\ninterface IFluidDex is IFluidAdminDex, IFluidUserDex {\n}\n\ninterface IFluidDexResolver {\n    struct Configs {\n        bool isSmartCollateralEnabled;\n        bool isSmartDebtEnabled;\n        uint256 fee;\n        uint256 revenueCut;\n        uint256 upperRange;\n        uint256 lowerRange;\n        uint256 upperShiftThreshold;\n        uint256 lowerShiftThreshold;\n        uint256 shiftingTime;\n        address centerPriceAddress;\n        address hookAddress;\n        uint256 maxCenterPrice;\n        uint256 minCenterPrice;\n        uint256 utilizationLimitToken0;\n        uint256 utilizationLimitToken1;\n        uint256 maxSupplyShares;\n        uint256 maxBorrowShares;\n    }\n\n    function getDexConfigs(\n        address dex_\n    ) external view returns (Configs memory configs_);\n}"
      },
      "project/contracts/payloads/common/interfaces/IFluidDexFactory.sol": {
        "content": "pragma solidity ^0.8.21;\n\ninterface IFluidDexFactory {\n    /// @notice                         Computes the address of a dex based on its given ID (`dexId_`).\n    /// @param dexId_                   The ID of the dex.\n    /// @return dex_                    Returns the computed address of the dex.\n    function getDexAddress(uint256 dexId_) external view returns (address dex_);\n\n    function setDexAuth(address dex_, address dexAuth_, bool allowed_) external;\n\n    /// @notice                         Sets an address (`globalAuth_`) as a global authorization or not.\n    ///                                 This function can only be called by the owner.\n    /// @param globalAuth_              The address to be set as global authorization.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to update any dex config.\n    function setGlobalAuth(address globalAuth_, bool allowed_) external;\n\n    /// @notice Sets an address as a factory-level authorization or not.\n    /// @param auth The address to be set as factory authorization.\n    /// @param allowed A boolean indicating whether the specified address is allowed as factory auth.\n    function setFactoryAuth(address auth, bool allowed) external;\n\n    /// @notice Sets an address as a deployer or not.\n    /// @param deployer_ The address to be set as deployer.\n    /// @param allowed_ A boolean indicating whether the specified address is allowed as deployer.\n    function setDeployer(address deployer_, bool allowed_) external;\n\n    function owner() external view returns (address);\n\n    function setDexDeploymentLogic(\n        address deploymentLogic_,\n        bool allowed_\n    ) external;\n}"
      },
      "project/contracts/payloads/common/interfaces/IFluidLendingFactory.sol": {
        "content": "pragma solidity ^0.8.21;\n\ninterface IFluidLendingFactory {\n    /// @notice Computes the address of a token based on the asset and fToken type.\n    /// @param asset_ The address of the underlying asset.\n    /// @param fTokenType_ The type of fToken (e.g., \"fToken\" or \"NativeUnderlying\").\n    /// @return The computed address of the token.\n    function computeToken(address asset_, string calldata fTokenType_) external view returns (address);\n\n    /// @notice Sets an address as a factory-level authorization or not.\n    /// @param auth The address to be set as factory authorization.\n    /// @param allowed A boolean indicating whether the specified address is allowed as factory auth.\n    function setFactoryAuth(address auth, bool allowed) external;\n\n    /// @notice Sets an address as a deployer or not.\n    /// @param deployer_ The address to be set as deployer.\n    /// @param allowed_ A boolean indicating whether the specified address is allowed as deployer.\n    function setDeployer(address deployer_, bool allowed_) external;\n}"
      },
      "project/contracts/payloads/common/interfaces/IFluidLiquidity.sol": {
        "content": "pragma solidity ^0.8.21;\npragma experimental ABIEncoderV2;\n\ninterface AdminModuleStructs {\n    struct AddressBool {\n        address addr;\n        bool value;\n    }\n\n    struct AddressUint256 {\n        address addr;\n        uint256 value;\n    }\n\n    struct RateDataV1Params {\n        address token;\n        uint256 kink;\n        uint256 rateAtUtilizationZero;\n        uint256 rateAtUtilizationKink;\n        uint256 rateAtUtilizationMax;\n    }\n\n    struct RateDataV2Params {\n        address token;\n        uint256 kink1;\n        uint256 kink2;\n        uint256 rateAtUtilizationZero;\n        uint256 rateAtUtilizationKink1;\n        uint256 rateAtUtilizationKink2;\n        uint256 rateAtUtilizationMax;\n    }\n\n    struct TokenConfig {\n        address token;\n        uint256 fee;\n        uint256 threshold;\n        uint256 maxUtilization;\n    }\n\n    struct UserSupplyConfig {\n        address user;\n        address token;\n        uint8 mode;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseWithdrawalLimit;\n    }\n\n    struct UserBorrowConfig {\n        address user;\n        address token;\n        uint8 mode;\n        uint256 expandPercent;\n        uint256 expandDuration;\n        uint256 baseDebtCeiling;\n        uint256 maxDebtCeiling;\n    }\n}\n\ninterface IFluidLiquidityAdmin {\n    /// @notice adds/removes auths. Auths generally could be contracts which can have restricted actions defined on contract.\n    ///         auths can be helpful in reducing governance overhead where it's not needed.\n    /// @param authsStatus_ array of structs setting allowed status for an address.\n    ///                     status true => add auth, false => remove auth\n    function updateAuths(\n        AdminModuleStructs.AddressBool[] calldata authsStatus_\n    ) external;\n\n    /// @notice adds/removes guardians. Only callable by Governance.\n    /// @param guardiansStatus_ array of structs setting allowed status for an address.\n    ///                         status true => add guardian, false => remove guardian\n    function updateGuardians(\n        AdminModuleStructs.AddressBool[] calldata guardiansStatus_\n    ) external;\n\n    /// @notice changes the revenue collector address (contract that is sent revenue). Only callable by Governance.\n    /// @param revenueCollector_  new revenue collector address\n    function updateRevenueCollector(address revenueCollector_) external;\n\n    /// @notice changes current status, e.g. for pausing or unpausing all user operations. Only callable by Auths.\n    /// @param newStatus_ new status\n    ///        status = 2 -> pause, status = 1 -> resume.\n    function changeStatus(uint256 newStatus_) external;\n\n    /// @notice                  update tokens rate data version 1. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV1Params with rate data to set for each token\n    function updateRateDataV1s(\n        AdminModuleStructs.RateDataV1Params[] calldata tokensRateData_\n    ) external;\n\n    /// @notice                  update tokens rate data version 2. Only callable by Auths.\n    /// @param tokensRateData_   array of RateDataV2Params with rate data to set for each token\n    function updateRateDataV2s(\n        AdminModuleStructs.RateDataV2Params[] calldata tokensRateData_\n    ) external;\n\n    /// @notice updates token configs: fee charge on borrowers interest & storage update utilization threshold.\n    ///         Only callable by Auths.\n    /// @param tokenConfigs_ contains token address, fee & utilization threshold\n    function updateTokenConfigs(\n        AdminModuleStructs.TokenConfig[] calldata tokenConfigs_\n    ) external;\n\n    /// @notice updates user classes: 0 is for new protocols, 1 is for established protocols.\n    ///         Only callable by Auths.\n    /// @param userClasses_ struct array of uint256 value to assign for each user address\n    function updateUserClasses(\n        AdminModuleStructs.AddressUint256[] calldata userClasses_\n    ) external;\n\n    /// @notice sets user supply configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userSupplyConfigs_ struct array containing user supply config, see `UserSupplyConfig` struct for more info\n    function updateUserSupplyConfigs(\n        AdminModuleStructs.UserSupplyConfig[] memory userSupplyConfigs_\n    ) external;\n\n    /// @notice setting user borrow configs per token basis. Eg: with interest or interest-free and automated limits.\n    ///         Only callable by Auths.\n    /// @param userBorrowConfigs_ struct array containing user borrow config, see `UserBorrowConfig` struct for more info\n    function updateUserBorrowConfigs(\n        AdminModuleStructs.UserBorrowConfig[] memory userBorrowConfigs_\n    ) external;\n\n    /// @notice pause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to pause operations for\n    /// @param supplyTokens_  token addresses to pause withdrawals for\n    /// @param borrowTokens_  token addresses to pause borrowings for\n    function pauseUser(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    ) external;\n\n    /// @notice unpause operations for a particular user in class 0 (class 1 users can't be paused by guardians).\n    /// Only callable by Guardians.\n    /// @param user_          address of user to unpause operations for\n    /// @param supplyTokens_  token addresses to unpause withdrawals for\n    /// @param borrowTokens_  token addresses to unpause borrowings for\n    function unpauseUser(\n        address user_,\n        address[] calldata supplyTokens_,\n        address[] calldata borrowTokens_\n    ) external;\n\n    /// @notice         collects revenue for tokens to configured revenueCollector address.\n    /// @param tokens_  array of tokens to collect revenue for\n    /// @dev            Note that this can revert if token balance is < revenueAmount (utilization > 100%)\n    function collectRevenue(address[] calldata tokens_) external;\n\n    /// @notice gets the current updated exchange prices for n tokens and updates all prices, rates related data in storage.\n    /// @param tokens_ tokens to update exchange prices for\n    /// @return supplyExchangePrices_ new supply rates of overall system for each token\n    /// @return borrowExchangePrices_ new borrow rates of overall system for each token\n    function updateExchangePrices(\n        address[] calldata tokens_\n    )\n        external\n        returns (\n            uint256[] memory supplyExchangePrices_,\n            uint256[] memory borrowExchangePrices_\n        );\n\n    function readFromStorage(\n        bytes32 slot_\n    ) external view returns (uint256 result_);\n}"
      },
      "project/contracts/payloads/common/interfaces/IFluidReserveContract.sol": {
        "content": "pragma solidity ^0.8.21;\npragma experimental ABIEncoderV2;\n\ninterface IFluidReserveContract {\n    function isRebalancer(address user) external returns (bool);\n\n    function rebalanceFToken(address protocol_) external;\n\n    function rebalanceVault(address protocol_) external;\n\n    function transferFunds(address token_) external;\n\n    function withdrawFunds(\n        address[] memory tokens_,\n        uint256[] memory amounts_,\n        address to_\n    ) external;\n\n    function getProtocolTokens(address protocol_) external;\n\n    function updateAuth(address auth_, bool isAuth_) external;\n\n    function updateRebalancer(address rebalancer_, bool isRebalancer_) external;\n\n    function approve(\n        address[] memory protocols_,\n        address[] memory tokens_,\n        uint256[] memory amounts_\n    ) external;\n\n    function revoke(\n        address[] memory protocols_,\n        address[] memory tokens_\n    ) external;\n}\n\ninterface IFluidReserveContractV2 {\n    function withdrawFunds(\n        address[] memory tokens_,\n        uint256[] memory amounts_,\n        address to_,\n        string memory reason_\n    ) external;\n}\n"
      },
      "project/contracts/payloads/common/interfaces/IFluidSmartLendingFactory.sol": {
        "content": "pragma solidity ^0.8.21;\n\ninterface IFluidSmartLendingFactory {\n    /// @notice Updates the authorization status of an address for a SmartLending contract. Only callable by owner.\n    /// @param smartLending_ The address of the SmartLending contract.\n    /// @param auth_ The address to be updated.\n    /// @param allowed_ The new authorization status.\n    function updateSmartLendingAuth(\n        address smartLending_,\n        address auth_,\n        bool allowed_\n    ) external;\n\n    /// @notice Sets the creation code for new SmartLending contracts. Only callable by owner.\n    /// @param creationCode_ New SmartLending contract creation code.\n    function setSmartLendingCreationCode(bytes calldata creationCode_) external;\n\n    /// @notice Computes the address of a SmartLending contract based on a given DEX ID.\n    /// @param dexId_ The ID of the DEX for which the SmartLending contract address is being computed.\n    /// @return The computed SmartLending contract address.\n    function getSmartLendingAddress(\n        uint256 dexId_\n    ) external view returns (address);\n\n    /// @notice Sets an address as a factory-level authorization or not.\n    /// @param auth The address to be set as factory authorization.\n    /// @param allowed A boolean indicating whether the specified address is allowed as factory auth.\n    function setFactoryAuth(address auth, bool allowed) external;\n\n    /// @notice Sets an address as a deployer or not.\n    /// @param deployer_ The address to be set as deployer.\n    /// @param allowed_ A boolean indicating whether the specified address is allowed as deployer.\n    function updateDeployer(address deployer_, bool allowed_) external;\n}\n"
      },
      "project/contracts/payloads/common/interfaces/IFluidVault.sol": {
        "content": "pragma solidity ^0.8.21;\n\ninterface IFluidVaultT1 {\n    /// @notice updates the Vault oracle to `newOracle_`. Must implement the FluidOracle interface.\n    function updateOracle(address newOracle_) external;\n\n    /// @notice updates the all Vault core settings according to input params.\n    /// All input values are expected in 1e2 (1% = 100, 100% = 10_000).\n    function updateCoreSettings(\n        uint256 supplyRateMagnifier_,\n        uint256 borrowRateMagnifier_,\n        uint256 collateralFactor_,\n        uint256 liquidationThreshold_,\n        uint256 liquidationMaxLimit_,\n        uint256 withdrawGap_,\n        uint256 liquidationPenalty_,\n        uint256 borrowFee_\n    ) external;\n\n    /// @notice updates the allowed rebalancer to `newRebalancer_`.\n    function updateRebalancer(address newRebalancer_) external;\n\n    /// @notice updates the supply rate magnifier to `supplyRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateSupplyRateMagnifier(uint supplyRateMagnifier_) external;\n\n    /// @notice updates the borrow rate magnifier to `borrowRateMagnifier_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowRateMagnifier(uint borrowRateMagnifier_) external;\n\n    /// @notice updates the collateral factor to `collateralFactor_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateCollateralFactor(uint collateralFactor_) external;\n\n    /// @notice updates the liquidation threshold to `liquidationThreshold_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationThreshold(uint liquidationThreshold_) external;\n\n    /// @notice updates the liquidation max limit to `liquidationMaxLimit_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationMaxLimit(uint liquidationMaxLimit_) external;\n\n    /// @notice updates the withdrawal gap to `withdrawGap_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateWithdrawGap(uint withdrawGap_) external;\n\n    /// @notice updates the liquidation penalty to `liquidationPenalty_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateLiquidationPenalty(uint liquidationPenalty_) external;\n\n    /// @notice updates the borrow fee to `borrowFee_`. Input in 1e2 (1% = 100, 100% = 10_000).\n    function updateBorrowFee(uint borrowFee_) external;\n\n    function readFromStorage(\n        bytes32 slot_\n    ) external view returns (uint256 result_);\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address adminImplementation;\n        address secondaryImplementation;\n        address supplyToken;\n        address borrowToken;\n        uint8 supplyDecimals;\n        uint8 borrowDecimals;\n        uint vaultId;\n        bytes32 liquiditySupplyExchangePriceSlot;\n        bytes32 liquidityBorrowExchangePriceSlot;\n        bytes32 liquidityUserSupplySlot;\n        bytes32 liquidityUserBorrowSlot;\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView()\n        external\n        view\n        returns (ConstantViews memory constantsView_);\n\n    function absorbDustDebt(uint[] memory nftIds) external;\n}\n\ninterface IFluidSmartVault {\n    function TYPE() external view returns (uint256);\n\n    struct Tokens {\n        address token0;\n        address token1;\n    }\n\n    struct ConstantViews {\n        address liquidity;\n        address factory;\n        address operateImplementation;\n        address adminImplementation;\n        address secondaryImplementation;\n        address deployer; // address which deploys oracle\n        address supply; // either liquidity layer or DEX protocol\n        address borrow; // either liquidity layer or DEX protocol\n        Tokens supplyToken; // if smart collateral then address of token0 & token1 else just supply token address at token0 and token1 as empty\n        Tokens borrowToken; // if smart debt then address of token0 & token1 else just borrow token address at token0 and token1 as empty\n        uint256 vaultId;\n        uint256 vaultType;\n        bytes32 supplyExchangePriceSlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 borrowExchangePriceSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n        bytes32 userSupplySlot; // if smart collateral then slot is from DEX protocol else from liquidity layer\n        bytes32 userBorrowSlot; // if smart debt then slot is from DEX protocol else from liquidity layer\n    }\n\n    /// @notice returns all Vault constants\n    function constantsView() external view returns (ConstantViews memory constantsView_);\n\n    function updateOracle(uint256 newOracle_) external;\n}\n\ninterface IFluidVault {\n    function updateOracle(uint256 newOracle_) external;\n}"
      },
      "project/contracts/payloads/common/interfaces/IFluidVaultFactory.sol": {
        "content": "pragma solidity ^0.8.21;\npragma experimental ABIEncoderV2;\ninterface IFluidVaultFactory {\n    /// @notice                         Sets an address as allowed vault deployment logic (`deploymentLogic_`) contract or not.\n    ///                                 This function can only be called by the owner.\n    /// @param deploymentLogic_         The address of the vault deployment logic contract to be set.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to deploy new type of vault.\n    function setVaultDeploymentLogic(\n        address deploymentLogic_,\n        bool allowed_\n    ) external;\n\n    /// @notice                         Sets an address (`vaultAuth_`) as allowed vault authorization or not for a specific vault (`vault_`).\n    ///                                 This function can only be called by the owner.\n    /// @param vault_                   The address of the vault for which the authorization is being set.\n    /// @param vaultAuth_               The address to be set as vault authorization.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to update the specific vault config.\n    function setVaultAuth(\n        address vault_,\n        address vaultAuth_,\n        bool allowed_\n    ) external;\n\n    /// @notice                         Computes the address of a vault based on its given ID (`vaultId_`).\n    /// @param vaultId_                 The ID of the vault.\n    /// @return vault_                  Returns the computed address of the vault.\n    function getVaultAddress(\n        uint256 vaultId_\n    ) external view returns (address vault_);\n\n     /// @notice                         Sets an address (`globalAuth_`) as a global authorization or not.\n    ///                                 This function can only be called by the owner.\n    /// @param globalAuth_              The address to be set as global authorization.\n    /// @param allowed_                 A boolean indicating whether the specified address is allowed to update any vault config.\n    function setGlobalAuth(address globalAuth_, bool allowed_) external;\n\n    /// @notice Sets an address as a factory-level authorization or not.\n    /// @param auth The address to be set as factory authorization.\n    /// @param allowed A boolean indicating whether the specified address is allowed as factory auth.\n    function setFactoryAuth(address auth, bool allowed) external;\n\n    /// @notice Sets an address as a deployer or not.\n    /// @param deployer_ The address to be set as deployer.\n    /// @param allowed_ A boolean indicating whether the specified address is allowed as deployer.\n    function setDeployer(address deployer_, bool allowed_) external;\n}"
      },
      "project/contracts/payloads/common/interfaces/IFToken.sol": {
        "content": "pragma solidity ^0.8.21;\n\ninterface IFTokenAdmin {\n    /// @notice updates the rewards rate model contract.\n    ///         Only callable by LendingFactory auths.\n    /// @param rewardsRateModel_  the new rewards rate model contract address.\n    ///                           can be set to address(0) to set no rewards (to save gas)\n    function updateRewards(address rewardsRateModel_) external;\n\n    /// @notice Balances out the difference between fToken supply at Liquidity vs totalAssets().\n    ///         Deposits underlying from rebalancer address into Liquidity but doesn't mint any shares\n    ///         -> thus making deposit available as rewards.\n    ///         Only callable by rebalancer.\n    /// @return assets_ amount deposited to Liquidity\n    function rebalance() external payable returns (uint256 assets_);\n\n    /// @notice gets the liquidity exchange price of the underlying asset, calculates the updated exchange price (with reward rates)\n    ///         and writes those values to storage.\n    ///         Callable by anyone.\n    /// @return tokenExchangePrice_ exchange price of fToken share to underlying asset\n    /// @return liquidityExchangePrice_ exchange price at Liquidity for the underlying asset\n    function updateRates()\n        external\n        returns (uint256 tokenExchangePrice_, uint256 liquidityExchangePrice_);\n\n    /// @notice sends any potentially stuck funds to Liquidity contract. Only callable by LendingFactory auths.\n    function rescueFunds(address token_) external;\n\n    /// @notice Updates the rebalancer address (ReserveContract). Only callable by LendingFactory auths.\n    function updateRebalancer(address rebalancer_) external;\n}\n\ninterface ILendingRewards {\n    function start() external;\n}"
      },
      "project/contracts/payloads/common/interfaces/IGovernorBravo.sol": {
        "content": "pragma solidity ^0.8.21;\npragma experimental ABIEncoderV2;\ninterface IGovernorBravo {\n    function _acceptAdmin() external;\n\n    function _setVotingDelay(uint256 newVotingDelay) external;\n\n    function _setVotingPeriod(uint256 newVotingPeriod) external;\n\n    function _acceptAdminOnTimelock() external;\n\n    function _setImplementation(address implementation_) external;\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        string[] memory signatures,\n        bytes[] memory calldatas,\n        string memory description\n    ) external returns (uint256);\n\n    function admin() external view returns (address);\n\n    function pendingAdmin() external view returns (address);\n\n    function timelock() external view returns (address);\n\n    function votingDelay() external view returns (uint256);\n\n    function votingPeriod() external view returns (uint256);\n}"
      },
      "project/contracts/payloads/common/interfaces/ILite.sol": {
        "content": "pragma solidity ^0.8.21;\n\ninterface ILite {\n    function setAdmin(address newAdmin) external;\n\n    function getAdmin() external view returns (address);\n\n    function removeImplementation(address implementation_) external;\n\n    function addImplementation(\n        address implementation_,\n        bytes4[] calldata sigs_\n    ) external;\n\n    function setDummyImplementation(address newDummyImplementation_) external;\n\n    function updateMaxRiskRatio(\n        uint8[] memory protocolId_,\n        uint256[] memory newRiskRatio_\n    ) external;\n\n    function updateAggrMaxVaultRatio(uint256 newAggrMaxVaultRatio_) external;\n\n    function addDSAAuth(address auth_) external;\n    \n    // Collect stETH revenue to the treasury address set in Lite\n    // amount_ is specified in stETH wei (1e18 per stETH)\n    function collectRevenue(uint256 amount_) external;\n        \n    function getImplementationSigs(address implementation_) external view returns (bytes4[] memory);\n    function updateSecondaryAuth(address secondaryAuth_) external;\n    function updateRebalancer(address rebalancer_, bool isRebalancer_) external;\n    function updateTreasury(address treasury_) external;\n}"
      },
      "project/contracts/payloads/common/interfaces/IProxy.sol": {
        "content": "pragma solidity ^0.8.21;\n\ninterface IProxy {\n    function upgradeToAndCall(address newImplementation, bytes memory data) external;\n}"
      },
      "project/contracts/payloads/common/interfaces/ISmartLending.sol": {
        "content": "pragma solidity ^0.8.21;\n\ninterface ISmartLendingAdmin {\n    /// @notice set the rebalancer address (ReserveContract). Only callable by SmartLendingFactory auths.\n    function setRebalancer(address rebalancer_) external;\n\n    /// @dev Set the fee or reward. Only callable by auths.\n    /// @param feeOrReward_ The new fee or reward (1e6 = 100%, 1e4 = 1%, minimum 0.0001% fee or reward). 0 means no fee or reward\n    function setFeeOrReward(int256 feeOrReward_) external;\n}"
      },
      "project/contracts/payloads/common/interfaces/ISmartLendingFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.21;\n\ninterface ISmartLendingFactory {\n    function setSmartLendingCreationCode(bytes memory creationCode) external;\n    /// @notice Sets an address as a factory-level authorization or not.\n    /// @param auth The address to be set as factory authorization.\n    /// @param allowed A boolean indicating whether the specified address is allowed as factory auth.\n    function setFactoryAuth(address auth, bool allowed) external;\n\n    /// @notice Sets an address as a deployer or not.\n    /// @param deployer_ The address to be set as deployer.\n    /// @param allowed_ A boolean indicating whether the specified address is allowed as deployer.\n    function updateDeployer(address deployer_, bool allowed_) external;\n} "
      },
      "project/contracts/payloads/common/interfaces/ITimelock.sol": {
        "content": "pragma solidity ^0.8.21;\npragma experimental ABIEncoderV2;\n\ninterface ITimelock {\n    function acceptAdmin() external;\n\n    function setDelay(uint256 delay_) external;\n\n    function setPendingAdmin(address pendingAdmin_) external;\n\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string memory signature,\n        bytes memory data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n\n    function pendingAdmin() external view returns (address);\n\n    function admin() external view returns (address);\n\n    function delay() external view returns (uint256);\n}"
      },
      "project/contracts/payloads/common/main.sol": {
        "content": "pragma solidity ^0.8.21;\npragma experimental ABIEncoderV2;\n\nimport {BigMathMinified} from \"../libraries/bigMathMinified.sol\";\nimport {LiquidityCalcs} from \"../libraries/liquidityCalcs.sol\";\nimport {LiquiditySlotsLink} from \"../libraries/liquiditySlotsLink.sol\";\n\nimport { IGovernorBravo } from \"./interfaces/IGovernorBravo.sol\";\nimport { ITimelock } from \"./interfaces/ITimelock.sol\";\n\nimport { IFluidLiquidityAdmin, AdminModuleStructs as FluidLiquidityAdminStructs } from \"./interfaces/IFluidLiquidity.sol\";\nimport { IFluidReserveContract } from \"./interfaces/IFluidReserveContract.sol\";\n\nimport { IFluidVaultFactory } from \"./interfaces/IFluidVaultFactory.sol\";\nimport { IFluidDexFactory } from \"./interfaces/IFluidDexFactory.sol\";\n\nimport { IFluidDex, IFluidAdminDex } from \"./interfaces/IFluidDex.sol\";\nimport { IFluidDexResolver } from \"./interfaces/IFluidDex.sol\";\n\nimport { IFluidVault } from \"./interfaces/IFluidVault.sol\";\nimport { IFluidVaultT1 } from \"./interfaces/IFluidVault.sol\";\n\nimport { IFTokenAdmin } from \"./interfaces/IFToken.sol\";\nimport { ILendingRewards } from \"./interfaces/IFToken.sol\";\n\nimport { IDSAV2 } from \"./interfaces/IDSA.sol\";\n\nimport { PayloadIGPConstants } from \"./constants.sol\";\nimport { PayloadIGPHelpers } from \"./helpers.sol\";\n\n\nabstract contract PayloadIGPMain is PayloadIGPHelpers {\n    /**\n     * |\n     * |     State Variables      |\n     * |__________________________\n     */\n    /// @notice The unix time when the proposal was created\n    uint40 internal _proposalCreationTime;\n\n    /// @notice Boolean value to check if the proposal is executable. Default is not executable.\n    bool internal _isProposalExecutable;\n\n    /// @notice Actions that can be skipped\n    mapping(uint256 => bool) internal _skipAction;\n\n    /// @notice Modifier to check if an action can be skipped\n    modifier isActionSkippable(uint256 action_) {\n        // If function is not skippable, then execute\n        if (!PayloadIGPMain(ADDRESS_THIS).actionStatus(action_)) {\n            _;\n        }\n    }\n\n     /**\n     * |\n     * |     Team Multisig Actions      |\n     * |__________________________________\n     */\n    function setActionsToSkip(\n        uint256[] calldata actionsToSkip_\n    ) external {\n        if (msg.sender != TEAM_MULTISIG) {\n            revert(\"not-team-multisig\");\n        }\n\n        for (uint256 i = 0; i < actionsToSkip_.length; i++) {\n            _skipAction[actionsToSkip_[i]] = true;\n        }\n    }\n\n    // @notice Allows the team multisig to toggle the proposal executable or not\n    // @param isExecutable_ The boolean value to set the proposal executable or not\n    function toggleExecutable(bool isExecutable_) external {\n        require(msg.sender == TEAM_MULTISIG, \"not-team-multisig\");\n        _isProposalExecutable = isExecutable_;\n    }\n\n\n    /**\n     * |\n     * |     Proposal Structure           |\n     * |__________________________________\n     */\n\n     function propose(string memory description) external {\n        require(\n            msg.sender == PROPOSER ||\n                msg.sender == TEAM_MULTISIG ||\n                address(this) == PROPOSER_AVO_MULTISIG ||\n                address(this) == PROPOSER_AVO_MULTISIG_2 ||\n                address(this) == PROPOSER_AVO_MULTISIG_3 ||\n                address(this) == PROPOSER_AVO_MULTISIG_4 ||\n                address(this) == PROPOSER_AVO_MULTISIG_5,\n            \"msg.sender-not-allowed\"\n        );\n\n        uint256 totalActions = 1;\n        address[] memory targets = new address[](totalActions);\n        uint256[] memory values = new uint256[](totalActions);\n        string[] memory signatures = new string[](totalActions);\n        bytes[] memory calldatas = new bytes[](totalActions);\n\n        targets[0] = address(TIMELOCK);\n        values[0] = 0;\n        signatures[0] = \"executePayload(address,string,bytes)\";\n        calldatas[0] = abi.encode(ADDRESS_THIS, \"execute()\", abi.encode());\n\n        uint256 proposedId = GOVERNOR.propose(\n            targets,\n            values,\n            signatures,\n            calldatas,\n            description\n        );\n\n        require(proposedId == _PROPOSAL_ID(), \"PROPOSAL_IS_NOT_SAME\");\n\n        if (msg.sender == PROPOSER || msg.sender == TEAM_MULTISIG) {\n            setProposalCreationTime(uint40(block.timestamp));\n        } else {\n            PayloadIGPMain(ADDRESS_THIS).setProposalCreationTime(uint40(block.timestamp));\n        }\n    }\n\n    function execute() public virtual {\n        require(address(this) == address(TIMELOCK), \"not-valid-caller\");\n        require(PayloadIGPMain(ADDRESS_THIS).isProposalExecutable(), \"proposal-not-executable\");\n    }\n\n    function verifyProposal() public view virtual {}\n\n    /**\n     * |\n     * |     Proposal Payload Helpers      |\n     * |__________________________________\n     */\n\n    function _PROPOSAL_ID() internal view virtual returns(uint256) {}\n\n    function setProposalCreationTime(uint40 proposalCreationTime_) public {\n        require(\n            msg.sender == PROPOSER ||\n                msg.sender == TEAM_MULTISIG ||\n                msg.sender == PROPOSER_AVO_MULTISIG ||\n                msg.sender == PROPOSER_AVO_MULTISIG_2 ||\n                msg.sender == PROPOSER_AVO_MULTISIG_3 ||\n                msg.sender == PROPOSER_AVO_MULTISIG_4 ||\n                msg.sender == PROPOSER_AVO_MULTISIG_5,\n            \"msg.sender-not-allowed\"\n        );\n        _proposalCreationTime = proposalCreationTime_;\n    }\n\n\n    function isProposalExecutable() public view returns (bool) {\n        return _isProposalExecutable;\n    }\n\n    function getProposalCreationTime() public view returns (uint40) {\n        return _proposalCreationTime;\n    }\n\n    function actionStatus(uint256 action_) public view returns (bool) {\n        return _skipAction[action_];\n    }\n}\n"
      },
      "project/contracts/payloads/IGP112/PayloadIGP112.sol": {
        "content": "pragma solidity ^0.8.21;\npragma experimental ABIEncoderV2;\n\nimport {BigMathMinified} from \"../libraries/bigMathMinified.sol\";\nimport {LiquidityCalcs} from \"../libraries/liquidityCalcs.sol\";\nimport {LiquiditySlotsLink} from \"../libraries/liquiditySlotsLink.sol\";\n\nimport {IGovernorBravo} from \"../common/interfaces/IGovernorBravo.sol\";\nimport {ITimelock} from \"../common/interfaces/ITimelock.sol\";\n\nimport {\n    IFluidLiquidityAdmin,\n    AdminModuleStructs as FluidLiquidityAdminStructs\n} from \"../common/interfaces/IFluidLiquidity.sol\";\nimport {\n    IFluidReserveContract,\n    IFluidReserveContractV2\n} from \"../common/interfaces/IFluidReserveContract.sol\";\n\nimport {IFluidVaultFactory} from \"../common/interfaces/IFluidVaultFactory.sol\";\nimport {IFluidDexFactory} from \"../common/interfaces/IFluidDexFactory.sol\";\n\nimport {\n    IFluidDex,\n    IFluidAdminDex,\n    IFluidDexResolver\n} from \"../common/interfaces/IFluidDex.sol\";\n\nimport {IFluidVault, IFluidVaultT1} from \"../common/interfaces/IFluidVault.sol\";\n\nimport {IFTokenAdmin, ILendingRewards} from \"../common/interfaces/IFToken.sol\";\n\nimport {ISmartLendingAdmin} from \"../common/interfaces/ISmartLending.sol\";\nimport {\n    ISmartLendingFactory\n} from \"../common/interfaces/ISmartLendingFactory.sol\";\nimport {\n    IFluidLendingFactory\n} from \"../common/interfaces/IFluidLendingFactory.sol\";\n\nimport {ICodeReader} from \"../common/interfaces/ICodeReader.sol\";\n\nimport {IDSAV2} from \"../common/interfaces/IDSA.sol\";\nimport {IERC20} from \"../common/interfaces/IERC20.sol\";\nimport {IProxy} from \"../common/interfaces/IProxy.sol\";\nimport {PayloadIGPConstants} from \"../common/constants.sol\";\nimport {PayloadIGPHelpers} from \"../common/helpers.sol\";\nimport {PayloadIGPMain} from \"../common/main.sol\";\nimport {ILite} from \"../common/interfaces/ILite.sol\";\n\ncontract PayloadIGP112 is PayloadIGPMain {\n    uint256 public constant PROPOSAL_ID = 112;\n\n    function execute() public virtual override {\n        super.execute();\n\n        // Action 1: Cleanup leftover allowances from Reserve contract\n        action1();\n\n        // Action 2: Clean up very old v1 vaults (1-10)\n        action2();\n\n        // Action 3: Max restrict deUSD-USDC DEX\n        action3();\n\n        // Action 4: Collect Lite vault revenue for buybacks\n        action4();\n\n        // Action 5: Update Lite treasury to Reserve contract\n        action5();\n\n        // Action 6: Update liquidation penalty on all USDT debt vaults\n        action6();\n\n        // Action 7: Launch USDe-JRUSDE and SRUSDE-USDe DEX limits\n        action7();\n\n        // Action 8: Upgrade Reserve Contract Implementation\n        action8();\n\n        // Action 9: Update syrupUSDC vault parameters\n        action9();\n\n        // Action 10: Collect liquidity layer revenue for buybacks\n        action10();\n    }\n\n    function verifyProposal() public view override {}\n\n    function _PROPOSAL_ID() internal view override returns (uint256) {\n        return PROPOSAL_ID;\n    }\n\n    // Struct to hold vault ID and new liquidation penalty\n    struct VaultLiquidationPenalty {\n        uint256 vaultId;\n        uint256 liquidationPenalty; // in 1e2 format (1% = 100)\n    }\n\n    struct VaultWithdrawalLimit {\n        uint256 vaultId;\n        uint256 baseWithdrawalLimitInUSD;\n    }\n\n    /**\n     * |\n     * |     Proposal Payload Actions      |\n     * |__________________________________\n     */\n\n    /// @notice Action 1: Cleanup leftover allowances from Reserve contract\n    function action1() internal isActionSkippable(1) {\n        address[] memory protocols_ = new address[](17);\n        protocols_[0] = 0x5C20B550819128074FD538Edf79791733ccEdd18;\n        protocols_[1] = 0x9Fb7b4477576Fe5B32be4C1843aFB1e55F251B33;\n        protocols_[2] = 0xE6b5D1CdC4935295c84772C4700932b4BFC93274;\n        protocols_[3] = 0x6F72895Cf6904489Bcd862c941c3D02a3eE4f03e;\n        protocols_[4] = 0xeAbBfca72F8a8bf14C4ac59e69ECB2eB69F0811C;\n        protocols_[5] = 0xbEC491FeF7B4f666b270F9D5E5C3f443cBf20991;\n        protocols_[6] = 0x51197586F6A9e2571868b6ffaef308f3bdfEd3aE;\n        protocols_[7] = 0x1c2bB46f36561bc4F05A94BD50916496aa501078;\n        protocols_[8] = 0x4045720a33193b4Fe66c94DFbc8D37B0b4D9B469;\n        protocols_[9] = 0xdF16AdaF80584b2723F3BA1Eb7a601338Ba18c4e;\n        protocols_[10] = 0x0C8C77B7FF4c2aF7F6CEBbe67350A490E3DD6cB3;\n        protocols_[11] = 0xE16A6f5359ABB1f61cE71e25dD0932e3E00B00eB;\n        protocols_[12] = 0x1982CC7b1570C2503282d0A0B41F69b3B28fdcc3;\n        protocols_[13] = 0xb4F3bf2d96139563777C0231899cE06EE95Cc946;\n        protocols_[14] = 0xBc345229C1b52e4c30530C614BB487323BA38Da5;\n        protocols_[15] = 0xF2c8F54447cbd591C396b0Dd7ac15FAF552d0FA4;\n        protocols_[16] = 0x92643E964CA4b2c165a95CA919b0A819acA6D5F1;\n\n        address[] memory tokens_ = new address[](17);\n        tokens_[0] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        tokens_[1] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        tokens_[2] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        tokens_[3] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        tokens_[4] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        tokens_[5] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        tokens_[6] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        tokens_[7] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        tokens_[8] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        tokens_[9] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        tokens_[10] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        tokens_[11] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        tokens_[12] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        tokens_[13] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        tokens_[14] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n        tokens_[15] = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; // USDC\n        tokens_[16] = 0xdAC17F958D2ee523a2206206994597C13D831ec7; // USDT\n\n        // Call revoke() on ReserveContractProxy to cleanup leftover allowances from IGP110\n        IFluidReserveContract(RESERVE_CONTRACT_PROXY).revoke(\n            protocols_,\n            tokens_\n        );\n    }\n\n    /// @notice Action 2: Reduce limits on very old v1 vaults (1-10)\n    function action2() internal isActionSkippable(2) {\n        VaultWithdrawalLimit[]\n            memory supplyLimits_ = new VaultWithdrawalLimit[](10);\n        supplyLimits_[0] = VaultWithdrawalLimit({\n            vaultId: 1,\n            baseWithdrawalLimitInUSD: 4_000\n        }); // ETH/USDC\n        supplyLimits_[1] = VaultWithdrawalLimit({\n            vaultId: 2,\n            baseWithdrawalLimitInUSD: 6_000\n        }); // ETH/USDT\n        supplyLimits_[2] = VaultWithdrawalLimit({\n            vaultId: 3,\n            baseWithdrawalLimitInUSD: 5_000\n        }); // wstETH/ETH\n        supplyLimits_[3] = VaultWithdrawalLimit({\n            vaultId: 4,\n            baseWithdrawalLimitInUSD: 4_000\n        }); // wstETH/USDC\n        supplyLimits_[4] = VaultWithdrawalLimit({\n            vaultId: 5,\n            baseWithdrawalLimitInUSD: 4_000\n        }); // wstETH/USDT\n        supplyLimits_[5] = VaultWithdrawalLimit({\n            vaultId: 6,\n            baseWithdrawalLimitInUSD: 8_000_000\n        }); // weETH/wstETH\n        supplyLimits_[6] = VaultWithdrawalLimit({\n            vaultId: 7,\n            baseWithdrawalLimitInUSD: 5_000\n        }); // sUSDe/USDC\n        supplyLimits_[7] = VaultWithdrawalLimit({\n            vaultId: 8,\n            baseWithdrawalLimitInUSD: 1_000\n        }); // sUSDe/USDT\n        supplyLimits_[8] = VaultWithdrawalLimit({\n            vaultId: 9,\n            baseWithdrawalLimitInUSD: 5_800_000\n        }); // weETH/USDC\n        supplyLimits_[9] = VaultWithdrawalLimit({\n            vaultId: 10,\n            baseWithdrawalLimitInUSD: 2_800_000\n        }); // weETH/USDT\n\n        for (uint256 i = 0; i < supplyLimits_.length; i++) {\n            address vault_ = getVaultAddress(supplyLimits_[i].vaultId);\n            IFluidVaultT1.ConstantViews memory constants_ = IFluidVaultT1(\n                vault_\n            ).constantsView();\n\n            SupplyProtocolConfig memory supplyConfig_ = SupplyProtocolConfig({\n                protocol: vault_,\n                supplyToken: constants_.supplyToken,\n                expandPercent: 25 * 1e2, // 25%\n                expandDuration: 12 hours, // 12 hours\n                baseWithdrawalLimitInUSD: supplyLimits_[i]\n                    .baseWithdrawalLimitInUSD\n            });\n            setSupplyProtocolLimits(supplyConfig_);\n            setBorrowProtocolLimitsPaused(vault_, constants_.borrowToken);\n        }\n    }\n\n    /// @notice Action 3: Max restrict deUSD-USDC DEX\n    function action3() internal isActionSkippable(3) {\n        address deUSD_USDC_DEX = getDexAddress(19);\n\n        // Set max supply shares to 10 (minimal limit to allow withdrawals)\n        IFluidDex(deUSD_USDC_DEX).updateMaxSupplyShares(10);\n    }\n\n    /// @notice Action 4: Collect Lite vault revenue for buybacks\n    function action4() internal isActionSkippable(4) {\n        uint256 STETH_AMOUNT = 85 * 1e18; // 85 stETH\n        IETHV2.collectRevenue(STETH_AMOUNT);\n\n        // Spell: Transfer 85 stETH from iETHv2 to Team Multisig\n        string[] memory targets = new string[](1);\n        bytes[] memory encodedSpells = new bytes[](1);\n\n        string\n            memory withdrawSignature = \"withdraw(address,uint256,address,uint256,uint256)\";\n        targets[0] = \"BASIC-A\";\n        encodedSpells[0] = abi.encodeWithSignature(\n            withdrawSignature,\n            stETH_ADDRESS,\n            STETH_AMOUNT,\n            address(TEAM_MULTISIG),\n            0,\n            0\n        );\n\n        IDSAV2(TREASURY).cast(targets, encodedSpells, address(this));\n    }\n\n    /// @notice Action 5: Update Lite treasury to Reserve contract\n    function action5() internal isActionSkippable(5) {\n        // Call updateTreasury directly on Lite contract\n        IETHV2.updateTreasury(address(FLUID_RESERVE));\n    }\n\n    /// @notice Action 6: Update liquidation penalty on all USDT debt vaults\n    function action6() internal isActionSkippable(6) {\n        // List of all USDT debt vaults with their new liquidation penalties\n        VaultLiquidationPenalty[] memory vaults = new VaultLiquidationPenalty[](\n            8\n        );\n\n        // ETH/USDT: 2% -> 1%\n        vaults[0] = VaultLiquidationPenalty({\n            vaultId: 12,\n            liquidationPenalty: 1 * 1e2\n        });\n\n        // wstETH/USDT: 3% -> 2.5%\n        vaults[1] = VaultLiquidationPenalty({\n            vaultId: 15,\n            liquidationPenalty: 250\n        }); // 2.5% = 250 in 1e2 format\n\n        // weETH/USDT: 4% -> 3%\n        vaults[2] = VaultLiquidationPenalty({\n            vaultId: 20,\n            liquidationPenalty: 3 * 1e2\n        });\n\n        // WBTC/USDT: 4% -> 3%\n        vaults[3] = VaultLiquidationPenalty({\n            vaultId: 22,\n            liquidationPenalty: 3 * 1e2\n        });\n\n        // cbBTC/USDT: 4% -> 3%\n        vaults[4] = VaultLiquidationPenalty({\n            vaultId: 30,\n            liquidationPenalty: 3 * 1e2\n        });\n\n        // tBTC/USDT: 4% -> 3%\n        vaults[5] = VaultLiquidationPenalty({\n            vaultId: 89,\n            liquidationPenalty: 3 * 1e2\n        });\n\n        // lBTC/USDT: 5% -> 4%\n        vaults[6] = VaultLiquidationPenalty({\n            vaultId: 108,\n            liquidationPenalty: 4 * 1e2\n        });\n\n        // USDe-USDtb/USDT (TYPE_2): 3% -> 2.5%\n        vaults[7] = VaultLiquidationPenalty({\n            vaultId: 137,\n            liquidationPenalty: 250\n        }); // 2.5% = 250 in 1e2 format\n\n        // Update liquidation penalty for each vault\n        for (uint256 i = 0; i < vaults.length; i++) {\n            address vaultAddress = getVaultAddress(vaults[i].vaultId);\n            IFluidVaultT1(vaultAddress).updateLiquidationPenalty(\n                vaults[i].liquidationPenalty\n            );\n        }\n    }\n\n    /// @notice Action 7: Launch USDe-JRUSDE and SRUSDE-USDe DEX limits and configure smart lending\n    function action7() internal isActionSkippable(7) {\n        // DEX ID 41: USDe-JRUSDE\n        address USDE_JRUSDE_DEX = getDexAddress(41);\n        DexConfig memory dexConfigUSDe_ = DexConfig({\n            dex: USDE_JRUSDE_DEX,\n            tokenA: USDe_ADDRESS,\n            tokenB: JRUSDE_ADDRESS,\n            smartCollateral: true,\n            smartDebt: false,\n            baseWithdrawalLimitInUSD: 5_500_000, // $5.5M per token\n            baseBorrowLimitInUSD: 0,\n            maxBorrowLimitInUSD: 0\n        });\n        setDexLimits(dexConfigUSDe_);\n\n        // DEX ID 42: SRUSDE-USDe\n        address SRUSDE_USDE_DEX = getDexAddress(42);\n        DexConfig memory dexConfigSRUs_ = DexConfig({\n            dex: SRUSDE_USDE_DEX,\n            tokenA: SRUSDE_ADDRESS,\n            tokenB: USDe_ADDRESS,\n            smartCollateral: true,\n            smartDebt: false,\n            baseWithdrawalLimitInUSD: 5_500_000, // $5.5M per token\n            baseBorrowLimitInUSD: 0,\n            maxBorrowLimitInUSD: 0\n        });\n        setDexLimits(dexConfigSRUs_);\n\n        // Launch supply shares cap\n        uint256 launchSupplyShares_ = 6_000_000 * 1e18; // $12M equivalent shares\n        IFluidDex(USDE_JRUSDE_DEX).updateMaxSupplyShares(launchSupplyShares_);\n        IFluidDex(SRUSDE_USDE_DEX).updateMaxSupplyShares(launchSupplyShares_);\n\n        // Configure smart lending rebalancers to Reserve contract\n        address fSL_USDE_JRUSDE = getSmartLendingAddress(41);\n        if (fSL_USDE_JRUSDE != address(0)) {\n            ISmartLendingAdmin(fSL_USDE_JRUSDE).setRebalancer(\n                address(FLUID_RESERVE)\n            );\n        }\n\n        address fSL_SRUSDE_USDE = getSmartLendingAddress(42);\n        if (fSL_SRUSDE_USDE != address(0)) {\n            ISmartLendingAdmin(fSL_SRUSDE_USDE).setRebalancer(\n                address(FLUID_RESERVE)\n            );\n        }\n\n        // Remove Team Multisig authorization on the DEXes post launch\n        DEX_FACTORY.setDexAuth(USDE_JRUSDE_DEX, TEAM_MULTISIG, false);\n        DEX_FACTORY.setDexAuth(SRUSDE_USDE_DEX, TEAM_MULTISIG, false);\n    }\n\n    /// @notice Action 8: Upgrade Reserve Contract Implementation\n    function action8() internal isActionSkippable(8) {\n        IProxy(address(FLUID_RESERVE)).upgradeToAndCall(\n            address(0xFb3102759F2d57F547b9C519db49Ce1fFDE15dB2),\n            abi.encode()\n        );\n    }\n\n    /// @notice Action 9: Update CF/LT on syrupUSDC vaults\n    function action9() internal isActionSkippable(9) {\n        uint256 collateralFactor = 90 * 1e2; // 90%\n        uint256 liquidationThreshold = 92 * 1e2; // 92%\n\n        for (uint256 i = 145; i <= 152; i++) {\n            address vault = getVaultAddress(i);\n            IFluidVaultT1(vault).updateLiquidationThreshold(\n                liquidationThreshold\n            );\n            IFluidVaultT1(vault).updateCollateralFactor(collateralFactor);\n        }\n    }\n\n    /// @notice Action 10: Collect liquidity layer revenue for buybacks\n    function action10() internal isActionSkippable(10) {\n        {\n            // liquidity layer revenue\n            address[] memory tokens = new address[](8);\n            tokens[0] = USDT_ADDRESS;\n            tokens[1] = wstETH_ADDRESS;\n            tokens[2] = ETH_ADDRESS;\n            tokens[3] = USDC_ADDRESS;\n            tokens[4] = sUSDe_ADDRESS;\n            tokens[5] = cbBTC_ADDRESS;\n            tokens[6] = WBTC_ADDRESS;\n            tokens[7] = GHO_ADDRESS;\n            LIQUIDITY.collectRevenue(tokens);\n        }\n        {\n            address[] memory tokens = new address[](8);\n            uint256[] memory amounts = new uint256[](8);\n            tokens[0] = USDT_ADDRESS;\n            amounts[0] =\n                IERC20(USDT_ADDRESS).balanceOf(address(FLUID_RESERVE)) -\n                10;\n            tokens[1] = wstETH_ADDRESS;\n            amounts[1] =\n                IERC20(wstETH_ADDRESS).balanceOf(address(FLUID_RESERVE)) -\n                0.1 ether;\n            tokens[2] = ETH_ADDRESS;\n            amounts[2] = address(FLUID_RESERVE).balance - 0.1 ether;\n            tokens[3] = USDC_ADDRESS;\n            amounts[3] =\n                IERC20(USDC_ADDRESS).balanceOf(address(FLUID_RESERVE)) -\n                10;\n            tokens[4] = sUSDe_ADDRESS;\n            amounts[4] =\n                IERC20(sUSDe_ADDRESS).balanceOf(address(FLUID_RESERVE)) -\n                0.1 ether;\n            tokens[5] = cbBTC_ADDRESS;\n            amounts[5] =\n                IERC20(cbBTC_ADDRESS).balanceOf(address(FLUID_RESERVE)) -\n                10;\n            tokens[6] = WBTC_ADDRESS;\n            amounts[6] =\n                IERC20(WBTC_ADDRESS).balanceOf(address(FLUID_RESERVE)) -\n                10;\n            tokens[7] = GHO_ADDRESS;\n            amounts[7] =\n                IERC20(GHO_ADDRESS).balanceOf(address(FLUID_RESERVE)) -\n                10;\n            IFluidReserveContractV2(address(FLUID_RESERVE)).withdrawFunds(\n                tokens,\n                amounts,\n                TEAM_MULTISIG,\n                \"revenue for buybacks\"\n            );\n        }\n    }\n    /**\n     * |\n     * |     Payload Actions End Here      |\n     * |__________________________________\n     */\n\n    // Token Prices Constants (same as other IGP files)\n    uint256 public constant ETH_USD_PRICE = 2_780 * 1e2;\n    uint256 public constant wstETH_USD_PRICE = 3_440 * 1e2;\n    uint256 public constant weETH_USD_PRICE = 3_050 * 1e2;\n    uint256 public constant rsETH_USD_PRICE = 2_980 * 1e2;\n    uint256 public constant weETHs_USD_PRICE = 2_920 * 1e2;\n    uint256 public constant mETH_USD_PRICE = 3_040 * 1e2;\n    uint256 public constant ezETH_USD_PRICE = 3_000 * 1e2;\n\n    uint256 public constant BTC_USD_PRICE = 86_000 * 1e2;\n\n    uint256 public constant STABLE_USD_PRICE = 1 * 1e2;\n    uint256 public constant sUSDe_USD_PRICE = 1.20 * 1e2;\n    uint256 public constant sUSDs_USD_PRICE = 1.08 * 1e2;\n    uint256 public constant syrupUSDT_USD_PRICE = 1.10 * 1e2;\n    uint256 public constant syrupUSDC_USD_PRICE = 1.14 * 1e2;\n\n    uint256 public constant FLUID_USD_PRICE = 3.32 * 1e2;\n\n    uint256 public constant RLP_USD_PRICE = 1.26 * 1e2;\n    uint256 public constant wstUSR_USD_PRICE = 1.12 * 1e2;\n    uint256 public constant XAUT_USD_PRICE = 4_040 * 1e2;\n    uint256 public constant PAXG_USD_PRICE = 4_050 * 1e2;\n    uint256 public constant JRUSDE_USD_PRICE = 1.00 * 1e2;\n    uint256 public constant SRUSDE_USD_PRICE = 1.00 * 1e2;\n\n    function getRawAmount(\n        address token,\n        uint256 amount,\n        uint256 amountInUSD,\n        bool isSupply\n    ) public view override returns (uint256) {\n        if (amount > 0 && amountInUSD > 0) {\n            revert(\"both usd and amount are not zero\");\n        }\n        uint256 exchangePriceAndConfig_ = LIQUIDITY.readFromStorage(\n            LiquiditySlotsLink.calculateMappingStorageSlot(\n                LiquiditySlotsLink.LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT,\n                token\n            )\n        );\n\n        (\n            uint256 supplyExchangePrice,\n            uint256 borrowExchangePrice\n        ) = LiquidityCalcs.calcExchangePrices(exchangePriceAndConfig_);\n\n        uint256 usdPrice = 0;\n        uint256 decimals = 18;\n        if (token == ETH_ADDRESS) {\n            usdPrice = ETH_USD_PRICE;\n            decimals = 18;\n        } else if (token == wstETH_ADDRESS) {\n            usdPrice = wstETH_USD_PRICE;\n            decimals = 18;\n        } else if (token == weETH_ADDRESS) {\n            usdPrice = weETH_USD_PRICE;\n            decimals = 18;\n        } else if (token == rsETH_ADDRESS) {\n            usdPrice = rsETH_USD_PRICE;\n            decimals = 18;\n        } else if (token == weETHs_ADDRESS) {\n            usdPrice = weETHs_USD_PRICE;\n            decimals = 18;\n        } else if (token == mETH_ADDRESS) {\n            usdPrice = mETH_USD_PRICE;\n            decimals = 18;\n        } else if (token == ezETH_ADDRESS) {\n            usdPrice = ezETH_USD_PRICE;\n            decimals = 18;\n        } else if (\n            token == cbBTC_ADDRESS ||\n            token == WBTC_ADDRESS ||\n            token == eBTC_ADDRESS ||\n            token == lBTC_ADDRESS\n        ) {\n            usdPrice = BTC_USD_PRICE;\n            decimals = 8;\n        } else if (token == tBTC_ADDRESS) {\n            usdPrice = BTC_USD_PRICE;\n            decimals = 18;\n        } else if (token == USDC_ADDRESS || token == USDT_ADDRESS) {\n            usdPrice = STABLE_USD_PRICE;\n            decimals = 6;\n        } else if (token == sUSDe_ADDRESS) {\n            usdPrice = sUSDe_USD_PRICE;\n            decimals = 18;\n        } else if (token == sUSDs_ADDRESS) {\n            usdPrice = sUSDs_USD_PRICE;\n            decimals = 18;\n        } else if (token == syrupUSDT_ADDRESS) {\n            usdPrice = syrupUSDT_USD_PRICE;\n            decimals = 6;\n        } else if (token == syrupUSDC_ADDRESS) {\n            usdPrice = syrupUSDC_USD_PRICE;\n            decimals = 6;\n        } else if (token == JRUSDE_ADDRESS) {\n            usdPrice = JRUSDE_USD_PRICE;\n            decimals = 18;\n        } else if (token == SRUSDE_ADDRESS) {\n            usdPrice = SRUSDE_USD_PRICE;\n            decimals = 18;\n        } else if (\n            token == GHO_ADDRESS ||\n            token == USDe_ADDRESS ||\n            token == deUSD_ADDRESS ||\n            token == USR_ADDRESS ||\n            token == USD0_ADDRESS ||\n            token == fxUSD_ADDRESS ||\n            token == BOLD_ADDRESS ||\n            token == iUSD_ADDRESS ||\n            token == USDTb_ADDRESS\n        ) {\n            usdPrice = STABLE_USD_PRICE;\n            decimals = 18;\n        } else if (token == INST_ADDRESS) {\n            usdPrice = FLUID_USD_PRICE;\n            decimals = 18;\n        } else if (token == wstUSR_ADDRESS) {\n            usdPrice = wstUSR_USD_PRICE;\n            decimals = 18;\n        } else if (token == RLP_ADDRESS) {\n            usdPrice = RLP_USD_PRICE;\n            decimals = 18;\n        } else if (token == XAUT_ADDRESS) {\n            usdPrice = XAUT_USD_PRICE;\n            decimals = 6;\n        } else if (token == PAXG_ADDRESS) {\n            usdPrice = PAXG_USD_PRICE;\n            decimals = 18;\n        } else {\n            revert(\"not-found\");\n        }\n\n        uint256 exchangePrice = isSupply\n            ? supplyExchangePrice\n            : borrowExchangePrice;\n\n        if (amount > 0) {\n            return (amount * 1e12) / exchangePrice;\n        } else {\n            return\n                (amountInUSD * 1e12 * (10 ** decimals)) /\n                ((usdPrice * exchangePrice) / 1e2);\n        }\n    }\n}\n"
      },
      "project/contracts/payloads/libraries/bigMathMinified.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @title library that represents a number in BigNumber(coefficient and exponent) format to store in smaller bits.\n/// @notice the number is divided into two parts: a coefficient and an exponent. This comes at a cost of losing some precision\n/// at the end of the number because the exponent simply fills it with zeroes. This precision is oftentimes negligible and can\n/// result in significant gas cost reduction due to storage space reduction.\n/// Also note, a valid big number is as follows: if the exponent is > 0, then coefficient last bits should be occupied to have max precision.\n/// @dev roundUp is more like a increase 1, which happens everytime for the same number.\n/// roundDown simply sets trailing digits after coefficientSize to zero (floor), only once for the same number.\nlibrary BigMathMinified {\n    /// @dev constants to use for `roundUp` input param to increase readability\n    bool internal constant ROUND_DOWN = false;\n    bool internal constant ROUND_UP = true;\n\n    /// @dev converts `normal` number to BigNumber with `exponent` and `coefficient` (or precision).\n    /// e.g.:\n    /// 5035703444687813576399599 (normal) = (coefficient[32bits], exponent[8bits])[40bits]\n    /// 5035703444687813576399599 (decimal) => 10000101010010110100000011111011110010100110100000000011100101001101001101011101111 (binary)\n    ///                                     => 10000101010010110100000011111011000000000000000000000000000000000000000000000000000\n    ///                                                                        ^-------------------- 51(exponent) -------------- ^\n    /// coefficient = 1000,0101,0100,1011,0100,0000,1111,1011               (2236301563)\n    /// exponent =                                            0011,0011     (51)\n    /// bigNumber =   1000,0101,0100,1011,0100,0000,1111,1011,0011,0011     (572493200179)\n    ///\n    /// @param normal number which needs to be converted into Big Number\n    /// @param coefficientSize at max how many bits of precision there should be (64 = uint64 (64 bits precision))\n    /// @param exponentSize at max how many bits of exponent there should be (8 = uint8 (8 bits exponent))\n    /// @param roundUp signals if result should be rounded down or up\n    /// @return bigNumber converted bigNumber (coefficient << exponent)\n    function toBigNumber(\n        uint256 normal,\n        uint256 coefficientSize,\n        uint256 exponentSize,\n        bool roundUp\n    ) internal pure returns (uint256 bigNumber) {\n        assembly {\n            let lastBit_\n            let number_ := normal\n            if gt(number_, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit_ := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit_ := add(lastBit_, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit_ := add(lastBit_, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit_ := add(lastBit_, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit_ := add(lastBit_, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit_ := add(lastBit_, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit_ := add(lastBit_, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if gt(number_, 0) {\n                lastBit_ := add(lastBit_, 1)\n            }\n            if lt(lastBit_, coefficientSize) {\n                // for throw exception\n                lastBit_ := coefficientSize\n            }\n            let exponent := sub(lastBit_, coefficientSize)\n            let coefficient := shr(exponent, normal)\n            if and(roundUp, gt(exponent, 0)) {\n                // rounding up is only needed if exponent is > 0, as otherwise the coefficient fully holds the original number\n                coefficient := add(coefficient, 1)\n                if eq(shl(coefficientSize, 1), coefficient) {\n                    // case were coefficient was e.g. 111, with adding 1 it became 1000 (in binary) and coefficientSize 3 bits\n                    // final coefficient would exceed it's size. -> reduce coefficent to 100 and increase exponent by 1.\n                    coefficient := shl(sub(coefficientSize, 1), 1)\n                    exponent := add(exponent, 1)\n                }\n            }\n            if iszero(lt(exponent, shl(exponentSize, 1))) {\n                // if exponent is >= exponentSize, the normal number is too big to fit within\n                // BigNumber with too small sizes for coefficient and exponent\n                revert(0, 0)\n            }\n            bigNumber := shl(exponentSize, coefficient)\n            bigNumber := add(bigNumber, exponent)\n        }\n    }\n\n    /// @dev get `normal` number from `bigNumber`, `exponentSize` and `exponentMask`\n    function fromBigNumber(\n        uint256 bigNumber,\n        uint256 exponentSize,\n        uint256 exponentMask\n    ) internal pure returns (uint256 normal) {\n        assembly {\n            let coefficient := shr(exponentSize, bigNumber)\n            let exponent := and(bigNumber, exponentMask)\n            normal := shl(exponent, coefficient)\n        }\n    }\n\n    /// @dev gets the most significant bit `lastBit` of a `normal` number (length of given number of binary format).\n    /// e.g.\n    /// 5035703444687813576399599 = 10000101010010110100000011111011110010100110100000000011100101001101001101011101111\n    /// lastBit =                   ^---------------------------------   83   ----------------------------------------^\n    function mostSignificantBit(uint256 normal) internal pure returns (uint lastBit) {\n        assembly {\n            let number_ := normal\n            if gt(normal, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x80, number_)\n                lastBit := 0x80\n            }\n            if gt(number_, 0xFFFFFFFFFFFFFFFF) {\n                number_ := shr(0x40, number_)\n                lastBit := add(lastBit, 0x40)\n            }\n            if gt(number_, 0xFFFFFFFF) {\n                number_ := shr(0x20, number_)\n                lastBit := add(lastBit, 0x20)\n            }\n            if gt(number_, 0xFFFF) {\n                number_ := shr(0x10, number_)\n                lastBit := add(lastBit, 0x10)\n            }\n            if gt(number_, 0xFF) {\n                number_ := shr(0x8, number_)\n                lastBit := add(lastBit, 0x8)\n            }\n            if gt(number_, 0xF) {\n                number_ := shr(0x4, number_)\n                lastBit := add(lastBit, 0x4)\n            }\n            if gt(number_, 0x3) {\n                number_ := shr(0x2, number_)\n                lastBit := add(lastBit, 0x2)\n            }\n            if gt(number_, 0x1) {\n                lastBit := add(lastBit, 1)\n            }\n            if gt(number_, 0) {\n                lastBit := add(lastBit, 1)\n            }\n        }\n    }\n}"
      },
      "project/contracts/payloads/libraries/dexSlotsLink.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Dex.\n/// @dev as all data for Fluid Dex is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidDexResolver.\nlibrary DexSlotsLink {\n    /// @dev storage slot for variables at Dex\n    uint256 internal constant DEX_VARIABLES_SLOT = 0;\n    /// @dev storage slot for variables2 at Dex\n    uint256 internal constant DEX_VARIABLES2_SLOT = 1;\n    /// @dev storage slot for total supply shares at Dex\n    uint256 internal constant DEX_TOTAL_SUPPLY_SHARES_SLOT = 2;\n    /// @dev storage slot for user supply mapping at Dex\n    uint256 internal constant DEX_USER_SUPPLY_MAPPING_SLOT = 3;\n    /// @dev storage slot for total borrow shares at Dex\n    uint256 internal constant DEX_TOTAL_BORROW_SHARES_SLOT = 4;\n    /// @dev storage slot for user borrow mapping at Dex\n    uint256 internal constant DEX_USER_BORROW_MAPPING_SLOT = 5;\n    /// @dev storage slot for oracle mapping at Dex\n    uint256 internal constant DEX_ORACLE_MAPPING_SLOT = 6;\n    /// @dev storage slot for range and threshold shifts at Dex\n    uint256 internal constant DEX_RANGE_THRESHOLD_SHIFTS_SLOT = 7;\n    /// @dev storage slot for center price shift at Dex\n    uint256 internal constant DEX_CENTER_PRICE_SHIFT_SLOT = 8;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_ALLOWED = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_ALLOWED = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Dex contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Dex contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}"
      },
      "project/contracts/payloads/libraries/errorTypes.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nlibrary LibsErrorTypes {\n    /***********************************|\n    |         LiquidityCalcs            | \n    |__________________________________*/\n\n    /// @notice thrown when supply or borrow exchange price is zero at calc token data (token not configured yet)\n    uint256 internal constant LiquidityCalcs__ExchangePriceZero = 70001;\n\n    /// @notice thrown when rate data is set to a version that is not implemented\n    uint256 internal constant LiquidityCalcs__UnsupportedRateVersion = 70002;\n\n    /// @notice thrown when the calculated borrow rate turns negative. This should never happen.\n    uint256 internal constant LiquidityCalcs__BorrowRateNegative = 70003;\n\n    /***********************************|\n    |           SafeTransfer            | \n    |__________________________________*/\n\n    /// @notice thrown when safe transfer from for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFromFailed = 71001;\n\n    /// @notice thrown when safe transfer for an ERC20 fails\n    uint256 internal constant SafeTransfer__TransferFailed = 71002;\n}"
      },
      "project/contracts/payloads/libraries/liquidityCalcs.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\nimport { LibsErrorTypes as ErrorTypes } from \"./errorTypes.sol\";\nimport { LiquiditySlotsLink } from \"./liquiditySlotsLink.sol\";\nimport { BigMathMinified } from \"./bigMathMinified.sol\";\n\n/// @notice implements calculation methods used for Fluid liquidity such as updated exchange prices,\n/// borrow rate, withdrawal / borrow limits, revenue amount.\nlibrary LiquidityCalcs {\n    error FluidLiquidityCalcsError(uint256 errorId_);\n\n    /// @notice emitted if the calculated borrow rate surpassed max borrow rate (16 bits) and was capped at maximum value 65535\n    event BorrowRateMaxCap();\n\n    /// @dev constants as from Liquidity variables.sol\n    uint256 internal constant EXCHANGE_PRICES_PRECISION = 1e12;\n\n    /// @dev Ignoring leap years\n    uint256 internal constant SECONDS_PER_YEAR = 365 days;\n    // constants used for BigMath conversion from and to storage\n    uint256 internal constant DEFAULT_EXPONENT_SIZE = 8;\n    uint256 internal constant DEFAULT_EXPONENT_MASK = 0xFF;\n\n    uint256 internal constant FOUR_DECIMALS = 1e4;\n    uint256 internal constant TWELVE_DECIMALS = 1e12;\n    uint256 internal constant X14 = 0x3fff;\n    uint256 internal constant X15 = 0x7fff;\n    uint256 internal constant X16 = 0xffff;\n    uint256 internal constant X18 = 0x3ffff;\n    uint256 internal constant X24 = 0xffffff;\n    uint256 internal constant X33 = 0x1ffffffff;\n    uint256 internal constant X64 = 0xffffffffffffffff;\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                  CALC EXCHANGE PRICES                  /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates interest (exchange prices) for a token given its' exchangePricesAndConfig from storage.\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @return supplyExchangePrice_ updated supplyExchangePrice\n    /// @return borrowExchangePrice_ updated borrowExchangePrice\n    function calcExchangePrices(\n        uint256 exchangePricesAndConfig_\n    ) internal view returns (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) {\n        // Extracting exchange prices\n        supplyExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE) &\n            X64;\n        borrowExchangePrice_ =\n            (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE) &\n            X64;\n\n        if (supplyExchangePrice_ == 0 || borrowExchangePrice_ == 0) {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__ExchangePriceZero);\n        }\n\n        uint256 temp_ = exchangePricesAndConfig_ & X16; // temp_ = borrowRate\n\n        unchecked {\n            // last timestamp can not be > current timestamp\n            uint256 secondsSinceLastUpdate_ = block.timestamp -\n                ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_LAST_TIMESTAMP) & X33);\n\n            uint256 borrowRatio_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_BORROW_RATIO) &\n                X15;\n            if (secondsSinceLastUpdate_ == 0 || temp_ == 0 || borrowRatio_ == 1) {\n                // if no time passed, borrow rate is 0, or no raw borrowings: no exchange price update needed\n                // (if borrowRatio_ == 1 means there is only borrowInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // calculate new borrow exchange price.\n            // formula borrowExchangePriceIncrease: previous price * borrow rate * secondsSinceLastUpdate_.\n            // nominator is max uint112 (uint64 * uint16 * uint32). Divisor can not be 0.\n            borrowExchangePrice_ +=\n                (borrowExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS);\n\n            // FOR SUPPLY EXCHANGE PRICE:\n            // all yield paid by borrowers (in mode with interest) goes to suppliers in mode with interest.\n            // formula: previous price * supply rate * secondsSinceLastUpdate_.\n            // where supply rate = (borrow rate  - revenueFee%) * ratioSupplyYield. And\n            // ratioSupplyYield = utilization * supplyRatio * borrowRatio\n            //\n            // Example:\n            // supplyRawInterest is 80, supplyInterestFree is 20. totalSupply is 100. BorrowedRawInterest is 50.\n            // BorrowInterestFree is 10. TotalBorrow is 60. borrow rate 40%, revenueFee 10%.\n            // yield is 10 (so half a year must have passed).\n            // supplyRawInterest must become worth 89. totalSupply must become 109. BorrowedRawInterest must become 60.\n            // borrowInterestFree must still be 10. supplyInterestFree still 20. totalBorrow 70.\n            // supplyExchangePrice would have to go from 1 to 1,125 (+ 0.125). borrowExchangePrice from 1 to 1,2 (+0.2).\n            // utilization is 60%. supplyRatio = 20 / 80 = 25% (only 80% of lenders receiving yield).\n            // borrowRatio = 10 / 50 = 20% (only 83,333% of borrowers paying yield):\n            // x of borrowers paying yield = 100% - (20 / (100 + 20)) = 100% - 16.6666666% = 83,333%.\n            // ratioSupplyYield = 60% * 83,33333% * (100% + 20%) = 62,5%\n            // supplyRate = (40% * (100% - 10%)) * = 36% * 62,5% = 22.5%\n            // increase in supplyExchangePrice, assuming 100 as previous price.\n            // 100 * 22,5% * 1/2 (half a year) = 0,1125.\n            // cross-check supplyRawInterest worth = 80 * 1.1125 = 89. totalSupply worth = 89 + 20.\n\n            // -------------- 1. calculate ratioSupplyYield --------------------------------\n            // step1: utilization * supplyRatio (or actually part of lenders receiving yield)\n\n            // temp_ => supplyRatio (in 1e2: 100% = 10_000; 1% = 100 -> max value 16_383)\n            // if first bit 0 then ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n            // else ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n            temp_ = (exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_SUPPLY_RATIO) & X15;\n\n            if (temp_ == 1) {\n                // if no raw supply: no exchange price update needed\n                // (if supplyRatio_ == 1 means there is only supplyInterestFree, as first bit is 1 and rest is 0)\n                return (supplyExchangePrice_, borrowExchangePrice_);\n            }\n\n            // ratioSupplyYield precision is 1e27 as 100% for increased precision when supplyInterestFree > supplyWithInterest\n            if (temp_ & 1 == 1) {\n                // ratio is supplyWithInterest / supplyInterestFree (supplyInterestFree is bigger)\n                temp_ = temp_ >> 1;\n\n                // Note: case where temp_ == 0 (only supplyInterestFree, no yield) already covered by early return\n                // in the if statement a little above.\n\n                // based on above example but supplyRawInterest is 20, supplyInterestFree is 80. no fee.\n                // supplyRawInterest must become worth 30. totalSupply must become 110.\n                // supplyExchangePrice would have to go from 1 to 1,5. borrowExchangePrice from 1 to 1,2.\n                // so ratioSupplyYield must come out as 2.5 (250%).\n                // supplyRatio would be (20 * 10_000 / 80) = 2500. but must be inverted.\n                temp_ = (1e27 * FOUR_DECIMALS) / temp_; // e.g. 1e31 / 2500 = 4e27. (* 1e27 for precision)\n                // e.g. 5_000 * (1e27 + 4e27) / 1e27 = 25_000 (=250%).\n                temp_ =\n                    // utilization * (100% + 100% / supplyRatio)\n                    (((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) *\n                        (1e27 + temp_)) / // extract utilization (max 16_383 so there is no way this can overflow).\n                    (FOUR_DECIMALS);\n                // max possible value of temp_ here is 16383 * (1e27 + 1e31) / 1e4 = ~1.64e31\n            } else {\n                // ratio is supplyInterestFree / supplyWithInterest (supplyWithInterest is bigger)\n                temp_ = temp_ >> 1;\n                // if temp_ == 0 then only supplyWithInterest => full yield. temp_ is already 0\n\n                // e.g. 5_000 * 10_000 + (20 * 10_000 / 80) / 10_000 = 5000 * 12500 / 10000 = 6250 (=62.5%).\n                temp_ =\n                    // 1e27 * utilization * (100% + supplyRatio) / 100%\n                    (1e27 *\n                        ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_UTILIZATION) & X14) * // extract utilization (max 16_383 so there is no way this can overflow).\n                        (FOUR_DECIMALS + temp_)) /\n                    (FOUR_DECIMALS * FOUR_DECIMALS);\n                // max possible temp_ value: 1e27 * 16383 * 2e4 / 1e8 = 3.2766e27\n            }\n            // from here temp_ => ratioSupplyYield (utilization * supplyRatio part) scaled by 1e27. max possible value ~1.64e31\n\n            // step2 of ratioSupplyYield: add borrowRatio (only x% of borrowers paying yield)\n            if (borrowRatio_ & 1 == 1) {\n                // ratio is borrowWithInterest / borrowInterestFree (borrowInterestFree is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n\n                // Note: case where borrowRatio_ == 0 (only borrowInterestFree, no yield) already covered\n                // at the beginning of the method by early return if `borrowRatio_ == 1`.\n\n                // based on above example but borrowRawInterest is 10, borrowInterestFree is 50. no fee. borrowRatio = 20%.\n                // so only 16.66% of borrowers are paying yield. so the 100% - part of the formula is not needed.\n                // x of borrowers paying yield = (borrowRatio / (100 + borrowRatio)) = 16.6666666%\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                borrowRatio_ = (borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_);\n                // max value here for borrowRatio_ is (1e31 / (1e4 + 1e4))= 5e26 (= 50% of borrowers paying yield).\n            } else {\n                // ratio is borrowInterestFree / borrowWithInterest (borrowWithInterest is bigger)\n                borrowRatio_ = borrowRatio_ >> 1;\n\n                // borrowRatio_ => x of total bororwers paying yield. scale to 1e27.\n                // x of borrowers paying yield = 100% - (borrowRatio / (100 + borrowRatio)) = 100% - 16.6666666% = 83,333%.\n                borrowRatio_ = (1e27 - ((borrowRatio_ * 1e27) / (FOUR_DECIMALS + borrowRatio_)));\n                // borrowRatio can never be > 100%. so max subtraction can be 100% - 100% / 200%.\n                // or if borrowRatio_ is 0 -> 100% - 0. or if borrowRatio_ is 1 -> 100% - 1 / 101.\n                // max value here for borrowRatio_ is 1e27 - 0 = 1e27 (= 100% of borrowers paying yield).\n            }\n\n            // temp_ => ratioSupplyYield. scaled down from 1e25 = 1% each to normal percent precision 1e2 = 1%.\n            // max nominator value is ~1.64e31 * 1e27 = 1.64e58. max result = 1.64e8\n            temp_ = (FOUR_DECIMALS * temp_ * borrowRatio_) / 1e54;\n\n            // 2. calculate supply rate\n            // temp_ => supply rate (borrow rate  - revenueFee%) * ratioSupplyYield.\n            // division part is done in next step to increase precision. (divided by 2x FOUR_DECIMALS, fee + borrowRate)\n            // Note that all calculation divisions for supplyExchangePrice are rounded down.\n            // Note supply rate can be bigger than the borrowRate, e.g. if there are only few lenders with interest\n            // but more suppliers not earning interest.\n            temp_ = ((exchangePricesAndConfig_ & X16) * // borrow rate\n                temp_ * // ratioSupplyYield\n                (FOUR_DECIMALS - ((exchangePricesAndConfig_ >> LiquiditySlotsLink.BITS_EXCHANGE_PRICES_FEE) & X14))); // revenueFee\n            // fee can not be > 100%. max possible = 65535 * ~1.64e8 * 1e4 =~1.074774e17.\n\n            // 3. calculate increase in supply exchange price\n            supplyExchangePrice_ += ((supplyExchangePrice_ * temp_ * secondsSinceLastUpdate_) /\n                (SECONDS_PER_YEAR * FOUR_DECIMALS * FOUR_DECIMALS * FOUR_DECIMALS));\n            // max possible nominator = max uint 64 * 1.074774e17 * max uint32 = ~8.52e45. Denominator can not be 0.\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                     CALC REVENUE                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev gets the `revenueAmount_` for a token given its' totalAmounts and exchangePricesAndConfig from storage\n    /// and the current balance of the Fluid liquidity contract for the token.\n    /// @param totalAmounts_ total amounts packed uint256 read from storage\n    /// @param exchangePricesAndConfig_ exchange prices and config packed uint256 read from storage\n    /// @param liquidityTokenBalance_   current balance of Liquidity contract (IERC20(token_).balanceOf(address(this)))\n    /// @return revenueAmount_ collectable revenue amount\n    function calcRevenue(\n        uint256 totalAmounts_,\n        uint256 exchangePricesAndConfig_,\n        uint256 liquidityTokenBalance_\n    ) internal view returns (uint256 revenueAmount_) {\n        // @dev no need to super-optimize this method as it is only used by admin\n\n        // calculate the new exchange prices based on earned interest\n        (uint256 supplyExchangePrice_, uint256 borrowExchangePrice_) = calcExchangePrices(exchangePricesAndConfig_);\n\n        // total supply = interest free + with interest converted from raw\n        uint256 totalSupply_ = getTotalSupply(totalAmounts_, supplyExchangePrice_);\n\n        if (totalSupply_ > 0) {\n            // available revenue: balanceOf(token) + totalBorrowings - totalLendings.\n            revenueAmount_ = liquidityTokenBalance_ + getTotalBorrow(totalAmounts_, borrowExchangePrice_);\n            // ensure there is no possible case because of rounding etc. where this would revert,\n            // explicitly check if >\n            revenueAmount_ = revenueAmount_ > totalSupply_ ? revenueAmount_ - totalSupply_ : 0;\n            // Note: if utilization > 100% (totalSupply < totalBorrow), then all the amount above 100% utilization\n            // can only be revenue.\n        } else {\n            // if supply is 0, then rest of balance can be withdrawn as revenue so that no amounts get stuck\n            revenueAmount_ = liquidityTokenBalance_;\n        }\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC LIMITS                       /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev calculates withdrawal limit before an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and converted from BigMath\n    /// @return currentWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction.\n    ///         returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitBeforeOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_\n    ) internal view returns (uint256 currentWithdrawalLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet).\n        // first tx where timestamp is 0 will enter `if (lastWithdrawalLimit_ == 0)` because lastWithdrawalLimit_ is not set yet.\n        // returning max withdrawal allowed, which is not exactly right but doesn't matter because the first interaction must be\n        // a deposit anyway. Important is that it would not revert.\n\n        // Note the first time a deposit brings the user supply amount to above the base withdrawal limit, the active limit\n        // is the fully expanded limit immediately.\n\n        // extract last set withdrawal limit\n        uint256 lastWithdrawalLimit_ = (userSupplyData_ >>\n            LiquiditySlotsLink.BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT) & X64;\n        lastWithdrawalLimit_ =\n            (lastWithdrawalLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (lastWithdrawalLimit_ & DEFAULT_EXPONENT_MASK);\n        if (lastWithdrawalLimit_ == 0) {\n            // withdrawal limit is not activated. Max withdrawal allowed\n            return 0;\n        }\n\n        uint256 maxWithdrawableLimit_;\n        uint256 temp_;\n        unchecked {\n            // extract max withdrawable percent of user supply and\n            // calculate maximum withdrawable amount expandPercentage of user supply at full expansion duration elapsed\n            // e.g.: if 10% expandPercentage, meaning 10% is withdrawable after full expandDuration has elapsed.\n\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxWithdrawableLimit_ =\n                (((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14) * userSupply_) /\n                FOUR_DECIMALS;\n\n            // time elapsed since last withdrawal limit was set (in seconds)\n            // @dev last process timestamp is guaranteed to exist for withdrawal, as a supply must have happened before.\n            // last timestamp can not be > current timestamp\n            temp_ =\n                block.timestamp -\n                ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP) & X33);\n        }\n        // calculate withdrawable amount of expandPercent that is elapsed of expandDuration.\n        // e.g. if 60% of expandDuration has elapsed, then user should be able to withdraw 6% of user supply, down to 94%.\n        // Note: no explicit check for this needed, it is covered by setting minWithdrawalLimit_ if needed.\n        temp_ =\n            (maxWithdrawableLimit_ * temp_) /\n            // extract expand duration: After this, decrement won't happen (user can withdraw 100% of withdraw limit)\n            ((userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_DURATION) & X24); // expand duration can never be 0\n        // calculate expanded withdrawal limit: last withdrawal limit - withdrawable amount.\n        // Note: withdrawable amount here can grow bigger than userSupply if timeElapsed is a lot bigger than expandDuration,\n        // which would cause the subtraction `lastWithdrawalLimit_ - withdrawableAmount_` to revert. In that case, set 0\n        // which will cause minimum (fully expanded) withdrawal limit to be set in lines below.\n        unchecked {\n            // underflow explicitly checked & handled\n            currentWithdrawalLimit_ = lastWithdrawalLimit_ > temp_ ? lastWithdrawalLimit_ - temp_ : 0;\n            // calculate minimum withdrawal limit: minimum amount of user supply that must stay supplied at full expansion.\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - maxWithdrawableLimit_;\n        }\n        // if withdrawal limit is decreased below minimum then set minimum\n        // (e.g. when more than expandDuration time has elapsed)\n        if (temp_ > currentWithdrawalLimit_) {\n            currentWithdrawalLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates withdrawal limit after an operate execution:\n    /// amount of user supply that must stay supplied (not amount that can be withdrawn).\n    /// i.e. if user has supplied 100m and can withdraw 5M, this method returns the 95M, not the withdrawable amount 5M\n    /// @param userSupplyData_ user supply data packed uint256 from storage\n    /// @param userSupply_ current user supply amount already extracted from `userSupplyData_` and added / subtracted with the executed operate amount\n    /// @param newWithdrawalLimit_ current withdrawal limit updated for expansion since last interaction, result from `calcWithdrawalLimitBeforeOperate`\n    /// @return withdrawalLimit_ updated withdrawal limit that should be written to storage. returned value is in\n    ///                          raw for with interest mode, normal amount for interest free mode!\n    function calcWithdrawalLimitAfterOperate(\n        uint256 userSupplyData_,\n        uint256 userSupply_,\n        uint256 newWithdrawalLimit_\n    ) internal pure returns (uint256) {\n        // temp_ => base withdrawal limit. below this, maximum withdrawals are allowed\n        uint256 temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // if user supply is below base limit then max withdrawals are allowed\n        if (userSupply_ < temp_) {\n            return 0;\n        }\n        // temp_ => withdrawal limit expandPercent (is in 1e2 decimals)\n        temp_ = (userSupplyData_ >> LiquiditySlotsLink.BITS_USER_SUPPLY_EXPAND_PERCENT) & X14;\n        unchecked {\n            // temp_ => minimum withdrawal limit: userSupply - max withdrawable limit (userSupply * expandPercent))\n            // userSupply_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            // subtraction can not underflow as maxWithdrawableLimit_ is a percentage amount (<=100%) of userSupply_\n            temp_ = userSupply_ - ((userSupply_ * temp_) / FOUR_DECIMALS);\n        }\n        // if new (before operation) withdrawal limit is less than minimum limit then set minimum limit.\n        // e.g. can happen on new deposits. withdrawal limit is instantly fully expanded in a scenario where\n        // increased deposit amount outpaces withrawals.\n        if (temp_ > newWithdrawalLimit_) {\n            return temp_;\n        }\n        return newWithdrawalLimit_;\n    }\n\n    /// @dev calculates borrow limit before an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_`\n    /// @return currentBorrowLimit_ current borrow limit updated for expansion since last interaction. returned value is in\n    ///                             raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitBeforeOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_\n    ) internal view returns (uint256 currentBorrowLimit_) {\n        // @dev must support handling the case where timestamp is 0 (config is set but no interactions yet) -> base limit.\n        // first tx where timestamp is 0 will enter `if (maxExpandedBorrowLimit_ < baseBorrowLimit_)` because `userBorrow_` and thus\n        // `maxExpansionLimit_` and thus `maxExpandedBorrowLimit_` is 0 and `baseBorrowLimit_` can not be 0.\n\n        // temp_ = extract borrow expand percent (is in 1e2 decimals)\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14;\n\n        uint256 maxExpansionLimit_;\n        uint256 maxExpandedBorrowLimit_;\n        unchecked {\n            // calculate max expansion limit: Max amount limit can expand to since last interaction\n            // userBorrow_ needs to be atleast 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            maxExpansionLimit_ = ((userBorrow_ * temp_) / FOUR_DECIMALS);\n\n            // calculate max borrow limit: Max point limit can increase to since last interaction\n            maxExpandedBorrowLimit_ = userBorrow_ + maxExpansionLimit_;\n        }\n\n        // currentBorrowLimit_ = extract base borrow limit\n        currentBorrowLimit_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        currentBorrowLimit_ =\n            (currentBorrowLimit_ >> DEFAULT_EXPONENT_SIZE) <<\n            (currentBorrowLimit_ & DEFAULT_EXPONENT_MASK);\n\n        if (maxExpandedBorrowLimit_ < currentBorrowLimit_) {\n            return currentBorrowLimit_;\n        }\n        // time elapsed since last borrow limit was set (in seconds)\n        unchecked {\n            // temp_ = timeElapsed_ (last timestamp can not be > current timestamp)\n            temp_ =\n                block.timestamp -\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP) & X33); // extract last update timestamp\n        }\n\n        // currentBorrowLimit_ = expandedBorrowableAmount + extract last set borrow limit\n        currentBorrowLimit_ =\n            // calculate borrow limit expansion since last interaction for `expandPercent` that is elapsed of `expandDuration`.\n            // divisor is extract expand duration (after this, full expansion to expandPercentage happened).\n            ((maxExpansionLimit_ * temp_) /\n                ((userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_DURATION) & X24)) + // expand duration can never be 0\n            //  extract last set borrow limit\n            BigMathMinified.fromBigNumber(\n                (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT) & X64,\n                DEFAULT_EXPONENT_SIZE,\n                DEFAULT_EXPONENT_MASK\n            );\n\n        // if timeElapsed is bigger than expandDuration, new borrow limit would be > max expansion,\n        // so set to `maxExpandedBorrowLimit_` in that case.\n        // also covers the case where last process timestamp = 0 (timeElapsed would simply be very big)\n        if (currentBorrowLimit_ > maxExpandedBorrowLimit_) {\n            currentBorrowLimit_ = maxExpandedBorrowLimit_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (currentBorrowLimit_ > temp_) {\n            currentBorrowLimit_ = temp_;\n        }\n    }\n\n    /// @dev calculates borrow limit after an operate execution:\n    /// total amount user borrow can reach (not borrowable amount in current operation).\n    /// i.e. if user has borrowed 50M and can still borrow 5M, this method returns the total 55M, not the borrowable amount 5M\n    /// @param userBorrowData_ user borrow data packed uint256 from storage\n    /// @param userBorrow_ current user borrow amount already extracted from `userBorrowData_` and added / subtracted with the executed operate amount\n    /// @param newBorrowLimit_ current borrow limit updated for expansion since last interaction, result from `calcBorrowLimitBeforeOperate`\n    /// @return borrowLimit_ updated borrow limit that should be written to storage.\n    ///                      returned value is in raw for with interest mode, normal amount for interest free mode!\n    function calcBorrowLimitAfterOperate(\n        uint256 userBorrowData_,\n        uint256 userBorrow_,\n        uint256 newBorrowLimit_\n    ) internal pure returns (uint256 borrowLimit_) {\n        // temp_ = extract borrow expand percent\n        uint256 temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_EXPAND_PERCENT) & X14; // (is in 1e2 decimals)\n\n        unchecked {\n            // borrowLimit_ = calculate maximum borrow limit at full expansion.\n            // userBorrow_ needs to be at least 1e73 to overflow max limit of ~1e77 in uint256 (no token in existence where this is possible).\n            borrowLimit_ = userBorrow_ + ((userBorrow_ * temp_) / FOUR_DECIMALS);\n        }\n\n        // temp_ = extract base borrow limit\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_BASE_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        if (borrowLimit_ < temp_) {\n            // below base limit, borrow limit is always base limit\n            return temp_;\n        }\n        // temp_ = extract hard max borrow limit. Above this user can never borrow (not expandable above)\n        temp_ = (userBorrowData_ >> LiquiditySlotsLink.BITS_USER_BORROW_MAX_BORROW_LIMIT) & X18;\n        temp_ = (temp_ >> DEFAULT_EXPONENT_SIZE) << (temp_ & DEFAULT_EXPONENT_MASK);\n\n        // make sure fully expanded borrow limit is not above hard max borrow limit\n        if (borrowLimit_ > temp_) {\n            borrowLimit_ = temp_;\n        }\n        // if new borrow limit (from before operate) is > max borrow limit, set max borrow limit.\n        // (e.g. on a repay shrinking instantly to fully expanded borrow limit from new borrow amount. shrinking is instant)\n        if (newBorrowLimit_ > borrowLimit_) {\n            return borrowLimit_;\n        }\n        return newBorrowLimit_;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //////////                      CALC RATES                        /////////\n    ///////////////////////////////////////////////////////////////////////////\n\n    /// @dev Calculates new borrow rate from utilization for a token\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_ totalBorrow / totalSupply. 1e4 = 100% utilization\n    /// @return rate_ rate for that particular token in 1e2 precision (e.g. 5% rate = 500)\n    function calcBorrowRateFromUtilization(uint256 rateData_, uint256 utilization_) internal returns (uint256 rate_) {\n        // extract rate version: 4 bits (0xF) starting from bit 0\n        uint256 rateVersion_ = (rateData_ & 0xF);\n\n        if (rateVersion_ == 1) {\n            rate_ = calcRateV1(rateData_, utilization_);\n        } else if (rateVersion_ == 2) {\n            rate_ = calcRateV2(rateData_, utilization_);\n        } else {\n            revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__UnsupportedRateVersion);\n        }\n\n        if (rate_ > X16) {\n            // hard cap for borrow rate at maximum value 16 bits (65535) to make sure it does not overflow storage space.\n            // this is unlikely to ever happen if configs stay within expected levels.\n            rate_ = X16;\n            // emit event to more easily become aware\n            emit BorrowRateMaxCap();\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 1 (with one kink) in 1e2 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e2 precision\n    function calcRateV1(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v1 (one kink) ------------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 188 bits =>  68-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_UTILIZATION_AT_KINK) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // else utilization is greater than kink\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX) & X16;\n            x1_ = kink1_;\n            x2_ = FOUR_DECIMALS; // 100%\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev calculates the borrow rate based on utilization for rate data version 2 (with two kinks) in 1e4 precision\n    /// @param rateData_ rate data packed uint256 from storage for the token\n    /// @param utilization_  in 1e2 (100% = 1e4)\n    /// @return rate_ rate in 1e4 precision\n    function calcRateV2(uint256 rateData_, uint256 utilization_) internal pure returns (uint256 rate_) {\n        /// For rate v2 (two kinks) -----------------------------------------------------\n        /// Next 16  bits =>  4 - 19 => Rate at utilization 0% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  20- 35 => Utilization at kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  36- 51 => Rate at utilization kink1 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  52- 67 => Utilization at kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  68- 83 => Rate at utilization kink2 (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Next 16  bits =>  84- 99 => Rate at utilization 100% (in 1e2: 100% = 10_000; 1% = 100 -> max value 65535)\n        /// Last 156 bits => 100-255 => blank, might come in use in future\n\n        // y = mx + c.\n        // y is borrow rate\n        // x is utilization\n        // m = slope (m can also be negative for declining rates)\n        // c is constant (c can be negative)\n\n        uint256 y1_;\n        uint256 y2_;\n        uint256 x1_;\n        uint256 x2_;\n\n        // extract kink1: 16 bits (0xFFFF) starting from bit 20\n        // kink is in 1e2, same as utilization, so no conversion needed for direct comparison of the two\n        uint256 kink1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1) & X16;\n        if (utilization_ < kink1_) {\n            // if utilization is less than kink1\n            y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO) & X16;\n            y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n            x1_ = 0; // 0%\n            x2_ = kink1_;\n        } else {\n            // extract kink2: 16 bits (0xFFFF) starting from bit 52\n            uint256 kink2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2) & X16;\n            if (utilization_ < kink2_) {\n                // if utilization is less than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                x1_ = kink1_;\n                x2_ = kink2_;\n            } else {\n                // else utilization is greater than kink2\n                y1_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2) & X16;\n                y2_ = (rateData_ >> LiquiditySlotsLink.BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX) & X16;\n                x1_ = kink2_;\n                x2_ = FOUR_DECIMALS;\n            }\n        }\n\n        int256 constant_;\n        int256 slope_;\n        unchecked {\n            // calculating slope with twelve decimal precision. m = (y2 - y1) / (x2 - x1).\n            // utilization of x2 can not be <= utilization of x1 (so no underflow or 0 divisor)\n            // y is in 1e2 so can not overflow when multiplied with TWELVE_DECIMALS\n            slope_ = (int256(y2_ - y1_) * int256(TWELVE_DECIMALS)) / int256((x2_ - x1_));\n\n            // calculating constant at 12 decimal precision. slope is already in 12 decimal hence only multiple with y1. c = y - mx.\n            // maximum y1_ value is 65535. 65535 * 1e12 can not overflow int256\n            // maximum slope is 65535 - 0 * TWELVE_DECIMALS / 1 = 65535 * 1e12;\n            // maximum x1_ is 100% (9_999 actually) => slope_ * x1_ can not overflow int256\n            // subtraction most extreme case would be  0 - max value slope_ * x1_ => can not underflow int256\n            constant_ = int256(y1_ * TWELVE_DECIMALS) - (slope_ * int256(x1_));\n\n            // calculating new borrow rate\n            // - slope_ max value is 65535 * 1e12,\n            // - utilization max value is let's say 500% (extreme case where borrow rate increases borrow amount without new supply)\n            // - constant max value is 65535 * 1e12\n            // so max values are 65535 * 1e12 * 50_000 + 65535 * 1e12 -> 3.2768*10^21, which easily fits int256\n            // divisor TWELVE_DECIMALS can not be 0\n            slope_ = (slope_ * int256(utilization_)) + constant_; // reusing `slope_` as variable for gas savings\n            if (slope_ < 0) {\n                revert FluidLiquidityCalcsError(ErrorTypes.LiquidityCalcs__BorrowRateNegative);\n            }\n            rate_ = uint256(slope_) / TWELVE_DECIMALS;\n        }\n    }\n\n    /// @dev reads the total supply out of Liquidity packed storage `totalAmounts_` for `supplyExchangePrice_`\n    function getTotalSupply(\n        uint256 totalAmounts_,\n        uint256 supplyExchangePrice_\n    ) internal pure returns (uint256 totalSupply_) {\n        // totalSupply_ => supplyInterestFree\n        totalSupply_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE) & X64;\n        totalSupply_ = (totalSupply_ >> DEFAULT_EXPONENT_SIZE) << (totalSupply_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalSupplyRaw_ = totalAmounts_ & X64; // no shifting as supplyRaw is first 64 bits\n        totalSupplyRaw_ = (totalSupplyRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalSupplyRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalSupply = supplyInterestFree + supplyRawInterest normalized from raw\n        totalSupply_ += ((totalSupplyRaw_ * supplyExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n\n    /// @dev reads the total borrow out of Liquidity packed storage `totalAmounts_` for `borrowExchangePrice_`\n    function getTotalBorrow(\n        uint256 totalAmounts_,\n        uint256 borrowExchangePrice_\n    ) internal pure returns (uint256 totalBorrow_) {\n        // totalBorrow_ => borrowInterestFree\n        // no & mask needed for borrow interest free as it occupies the last bits in the storage slot\n        totalBorrow_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE);\n        totalBorrow_ = (totalBorrow_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrow_ & DEFAULT_EXPONENT_MASK);\n\n        uint256 totalBorrowRaw_ = (totalAmounts_ >> LiquiditySlotsLink.BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST) & X64;\n        totalBorrowRaw_ = (totalBorrowRaw_ >> DEFAULT_EXPONENT_SIZE) << (totalBorrowRaw_ & DEFAULT_EXPONENT_MASK);\n\n        // totalBorrow = borrowInterestFree + borrowRawInterest normalized from raw\n        totalBorrow_ += ((totalBorrowRaw_ * borrowExchangePrice_) / EXCHANGE_PRICES_PRECISION);\n    }\n}"
      },
      "project/contracts/payloads/libraries/liquiditySlotsLink.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.21;\n\n/// @notice library that helps in reading / working with storage slot data of Fluid Liquidity.\n/// @dev as all data for Fluid Liquidity is internal, any data must be fetched directly through manual\n/// slot reading through this library or, if gas usage is less important, through the FluidLiquidityResolver.\nlibrary LiquiditySlotsLink {\n    /// @dev storage slot for status at Liquidity\n    uint256 internal constant LIQUIDITY_STATUS_SLOT = 1;\n    /// @dev storage slot for auths mapping at Liquidity\n    uint256 internal constant LIQUIDITY_AUTHS_MAPPING_SLOT = 2;\n    /// @dev storage slot for guardians mapping at Liquidity\n    uint256 internal constant LIQUIDITY_GUARDIANS_MAPPING_SLOT = 3;\n    /// @dev storage slot for user class mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_CLASS_MAPPING_SLOT = 4;\n    /// @dev storage slot for exchangePricesAndConfig mapping at Liquidity\n    uint256 internal constant LIQUIDITY_EXCHANGE_PRICES_MAPPING_SLOT = 5;\n    /// @dev storage slot for rateData mapping at Liquidity\n    uint256 internal constant LIQUIDITY_RATE_DATA_MAPPING_SLOT = 6;\n    /// @dev storage slot for totalAmounts mapping at Liquidity\n    uint256 internal constant LIQUIDITY_TOTAL_AMOUNTS_MAPPING_SLOT = 7;\n    /// @dev storage slot for user supply double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_SUPPLY_DOUBLE_MAPPING_SLOT = 8;\n    /// @dev storage slot for user borrow double mapping at Liquidity\n    uint256 internal constant LIQUIDITY_USER_BORROW_DOUBLE_MAPPING_SLOT = 9;\n    /// @dev storage slot for listed tokens array at Liquidity\n    uint256 internal constant LIQUIDITY_LISTED_TOKENS_ARRAY_SLOT = 10;\n\n    // --------------------------------\n    // @dev stacked uint256 storage slots bits position data for each:\n\n    // ExchangePricesAndConfig\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATE = 0;\n    uint256 internal constant BITS_EXCHANGE_PRICES_FEE = 16;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UTILIZATION = 30;\n    uint256 internal constant BITS_EXCHANGE_PRICES_UPDATE_THRESHOLD = 44;\n    uint256 internal constant BITS_EXCHANGE_PRICES_LAST_TIMESTAMP = 58;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_EXCHANGE_PRICE = 91;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_EXCHANGE_PRICE = 155;\n    uint256 internal constant BITS_EXCHANGE_PRICES_SUPPLY_RATIO = 219;\n    uint256 internal constant BITS_EXCHANGE_PRICES_BORROW_RATIO = 234;\n\n    // RateData:\n    uint256 internal constant BITS_RATE_DATA_VERSION = 0;\n    // RateData: V1\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V1_UTILIZATION_AT_KINK = 20;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_KINK = 36;\n    uint256 internal constant BITS_RATE_DATA_V1_RATE_AT_UTILIZATION_MAX = 52;\n    // RateData: V2\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_ZERO = 4;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK1 = 20;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK1 = 36;\n    uint256 internal constant BITS_RATE_DATA_V2_UTILIZATION_AT_KINK2 = 52;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_KINK2 = 68;\n    uint256 internal constant BITS_RATE_DATA_V2_RATE_AT_UTILIZATION_MAX = 84;\n\n    // TotalAmounts\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_WITH_INTEREST = 0;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_SUPPLY_INTEREST_FREE = 64;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_WITH_INTEREST = 128;\n    uint256 internal constant BITS_TOTAL_AMOUNTS_BORROW_INTEREST_FREE = 192;\n\n    // UserSupplyData\n    uint256 internal constant BITS_USER_SUPPLY_MODE = 0;\n    uint256 internal constant BITS_USER_SUPPLY_AMOUNT = 1;\n    uint256 internal constant BITS_USER_SUPPLY_PREVIOUS_WITHDRAWAL_LIMIT = 65;\n    uint256 internal constant BITS_USER_SUPPLY_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_SUPPLY_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_SUPPLY_BASE_WITHDRAWAL_LIMIT = 200;\n    uint256 internal constant BITS_USER_SUPPLY_IS_PAUSED = 255;\n\n    // UserBorrowData\n    uint256 internal constant BITS_USER_BORROW_MODE = 0;\n    uint256 internal constant BITS_USER_BORROW_AMOUNT = 1;\n    uint256 internal constant BITS_USER_BORROW_PREVIOUS_BORROW_LIMIT = 65;\n    uint256 internal constant BITS_USER_BORROW_LAST_UPDATE_TIMESTAMP = 129;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_PERCENT = 162;\n    uint256 internal constant BITS_USER_BORROW_EXPAND_DURATION = 176;\n    uint256 internal constant BITS_USER_BORROW_BASE_BORROW_LIMIT = 200;\n    uint256 internal constant BITS_USER_BORROW_MAX_BORROW_LIMIT = 218;\n    uint256 internal constant BITS_USER_BORROW_IS_PAUSED = 255;\n\n    // --------------------------------\n\n    /// @notice Calculating the slot ID for Liquidity contract for single mapping at `slot_` for `key_`\n    function calculateMappingStorageSlot(uint256 slot_, address key_) internal pure returns (bytes32) {\n        return keccak256(abi.encode(key_, slot_));\n    }\n\n    /// @notice Calculating the slot ID for Liquidity contract for double mapping at `slot_` for `key1_` and `key2_`\n    function calculateDoubleMappingStorageSlot(\n        uint256 slot_,\n        address key1_,\n        address key2_\n    ) internal pure returns (bytes32) {\n        bytes32 intermediateSlot_ = keccak256(abi.encode(key1_, slot_));\n        return keccak256(abi.encode(key2_, intermediateSlot_));\n    }\n}\n"
      }
    }
  }
}